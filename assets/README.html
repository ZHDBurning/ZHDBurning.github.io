<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>燃烧的炸弹猫 | 燃烧的炸弹猫</title><meta name="author" content="燃烧的炸弹猫"><meta name="copyright" content="燃烧的炸弹猫"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="1、网络的基本概念 R&amp;S&#x3D;路由交换 Datacom&#x3D;数通&#x3D;数据通信  数据通信：某个设备产生了数据之后，借助整体的网络到达目的地的过程。    网络历史 ——- 数通为什么产生？  1946年：世界上第一台计算机诞生。军事 科研 —– 高速运算 1962年：古巴导弹危机 1969年：美国国防部高级研究计划署ARPA “巨型网络” —- ARPAnet 阿帕网">
<meta property="og:type" content="website">
<meta property="og:title" content="燃烧的炸弹猫">
<meta property="og:url" content="http://example.com/assets/README.html">
<meta property="og:site_name" content="燃烧的炸弹猫">
<meta property="og:description" content="1、网络的基本概念 R&amp;S&#x3D;路由交换 Datacom&#x3D;数通&#x3D;数据通信  数据通信：某个设备产生了数据之后，借助整体的网络到达目的地的过程。    网络历史 ——- 数通为什么产生？  1946年：世界上第一台计算机诞生。军事 科研 —– 高速运算 1962年：古巴导弹危机 1969年：美国国防部高级研究计划署ARPA “巨型网络” —- ARPAnet 阿帕网">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://pic.imgdb.cn/item/654b452cc458853aef60e7d7.jpg">
<meta property="article:published_time" content="2023-08-17T08:11:33.356Z">
<meta property="article:modified_time" content="2023-08-17T08:11:33.325Z">
<meta property="article:author" content="燃烧的炸弹猫">
<meta property="article:tag" content="”博客,知识博客“">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://pic.imgdb.cn/item/654b452cc458853aef60e7d7.jpg"><link rel="shortcut icon" href="https://pic.imgdb.cn/item/654b452cc458853aef60e7d7.jpg"><link rel="canonical" href="http://example.com/assets/README.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":230},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"top-right"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '燃烧的炸弹猫',
  isPost: false,
  isHome: false,
  isHighlightShrink: false,
  isToc: false,
  postUpdate: '2023-08-17 16:11:33'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="/css/runtime.css" media="print" onload="this.media='all'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/654b452cc458853aef60e7d7.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">4</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">11</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><i class="fa-fw icon-home"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-home"></use></svg><span> 首页</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/archives/"><i class="fa-fw icon-kunnanjinguidang"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-kunnanjinguidang"></use></svg><span> 归档</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/tags/"><i class="fa-fw icon-biaoqianpai"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-biaoqianpai"></use></svg><span> 标签</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/categories/"><i class="fa-fw icon-shoukuanfenlei"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-shoukuanfenlei"></use></svg><span> 分类</span></a></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-liebiao"></use></svg><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-yinle">                   </use></svg><span> 音乐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/photo/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xiangce">                   </use></svg><span> 相册</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/comments/"><i class="fa-fw icon-liuyanban"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-liuyanban"></use></svg><span> 留言板</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/link/"><i class="fa-fw icon-lianjie"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-lianjie"></use></svg><span> 友链</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/about/"><i class="fa-fw icon-mianxingxinxingzuanshishuijing"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-mianxingxinxingzuanshishuijing"></use></svg><span> 关于</span></a></div></div></div></div><div class="page" id="body-wrap"><header class="not-home-page" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="燃烧的炸弹猫"><span class="site-name">燃烧的炸弹猫</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><i class="fa-fw icon-home"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-home"></use></svg><span> 首页</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/archives/"><i class="fa-fw icon-kunnanjinguidang"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-kunnanjinguidang"></use></svg><span> 归档</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/tags/"><i class="fa-fw icon-biaoqianpai"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-biaoqianpai"></use></svg><span> 标签</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/categories/"><i class="fa-fw icon-shoukuanfenlei"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-shoukuanfenlei"></use></svg><span> 分类</span></a></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-liebiao"></use></svg><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-yinle">                   </use></svg><span> 音乐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/photo/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xiangce">                   </use></svg><span> 相册</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/comments/"><i class="fa-fw icon-liuyanban"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-liuyanban"></use></svg><span> 留言板</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/link/"><i class="fa-fw icon-lianjie"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-lianjie"></use></svg><span> 友链</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/about/"><i class="fa-fw icon-mianxingxinxingzuanshishuijing"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-mianxingxinxingzuanshishuijing"></use></svg><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="page-site-info"><h1 id="site-title">燃烧的炸弹猫</h1></div></header><main class="layout" id="content-inner"><div id="page"><div id="article-container"><h2 id="1、网络的基本概念"><a href="#1、网络的基本概念" class="headerlink" title="1、网络的基本概念"></a>1、网络的基本概念</h2><blockquote>
<p>R&amp;S&#x3D;路由交换</p>
<p>Datacom&#x3D;数通&#x3D;数据通信</p>
<ul>
<li>数据通信：某个设备产生了数据之后，借助整体的网络到达目的地的过程。</li>
</ul>
</blockquote>
<blockquote>
<p>网络历史 ——- 数通为什么产生？</p>
<ul>
<li>1946年：世界上第一台计算机诞生。军事 科研 —– 高速运算</li>
<li>1962年：古巴导弹危机</li>
<li>1969年：美国国防部高级研究计划署ARPA “巨型网络” —- ARPAnet 阿帕网</li>
</ul>
</blockquote>
<blockquote>
<p>厂商垄断 —— 不能大规模普及 IBM</p>
<p>每个厂商都单独定义标准</p>
<p>问题：网络没有标准</p>
<ul>
<li><p>1977年：TCP&#x2F;IP架构（标准）</p>
</li>
<li><p>1980年：ARPAnet全面向TCP&#x2F;IP架构进行迁移</p>
</li>
<li><p>1984年：ISO —- 国际标准化组织机构（定义各行各业的标准）</p>
<p>​					OSI：开放式系统互联</p>
<p>​					同时，TCP&#x2F;IP模型全面推出</p>
</li>
</ul>
<p>工业标准：设备上使用的是通信型的标准TCP&#x2F;IP</p>
</blockquote>
<blockquote>
<p>总结：为什么要制定网络模型？</p>
<ul>
<li>统一化</li>
<li>分层管理</li>
<li>故障定位比较明确</li>
</ul>
</blockquote>
<blockquote>
<p>OSI：7层模型</p>
<p>7：应用层</p>
<p>6：表示层</p>
<p>5：会话层</p>
<p>4：传输层</p>
<p><strong><code>3：网络层</code></strong></p>
<p><strong><code>2：数据链路层</code></strong></p>
<p>1：物理层</p>
</blockquote>
<blockquote>
<p>TCP&#x2F;IP模型</p>
<p>4：应用层</p>
<p>3：传输层</p>
<p>2：网络层</p>
<p>1：网络接口层</p>
</blockquote>
<blockquote>
<p>TCP协议：传输控制协议</p>
<p>IP协议：互联网协议</p>
</blockquote>
<blockquote>
<p>服务器的组成：硬件、x86、电源、内存、cpu、风扇、硬盘</p>
<p>pc：办公、上网、娱乐、打游戏</p>
<p>服务器：一直开机，存放文件和数据，对外提供访问，相对于一台高性能的pc</p>
<blockquote>
<p>注：服务器不一定是一台普通的个人电脑（PC）。首先，服务器通常需要更高的性能和可靠性，因为它们需要处理更多的请求和数据。例如，一个承载高流量网站的服务器需要比一个普通的个人电脑拥有更强大的处理能力、更大的内存容量和更快的网络连接速度等。</p>
<p>其次，服务器通常需要更特殊的硬件和软件来支持其特殊的功能。例如，一台用于托管数据库的服务器通常需要更快的硬盘驱动器和更专业的数据库管理软件，而一台用于托管网站的服务器则需要更专业的Web服务器软件和安全性能。</p>
<p>此外，服务器通常会运行在一种以稳定性和安全性为重点的操作系统上，例如Linux或Windows Server等，以确保其运行稳定性和安全性。相比之下，大多数个人电脑运行的是桌面操作系统，例如Windows或MacOS，它们的设计目标更侧重于用户友好性和易用性。</p>
<p>综上所述，虽然服务器和个人电脑都是计算机系统，但由于它们的设计目标不同，所以它们在硬件、软件和操作系统等方面存在很大的差异。</p>
</blockquote>
</blockquote>
<blockquote>
<p>ISP &#x3D; 运营商（互联网服务的提供商），通常以一朵云代表一个运营商</p>
</blockquote>
<blockquote>
<p>翻墙（又称“穿越长城”）是指通过使用网络代理或虚拟专用网络（VPN）等技术，从国内网络环境连接到国外网络环境。这个“墙”指的是中国政府实施的互联网审查和过滤系统，也就是俗称的“防火长城”。</p>
<p>在中国，政府对互联网进行了广泛的监管和审查，限制了许多国外的网站和服务。这些限制包括阻止人们访问一些社交媒体、新闻网站以及搜索引擎等。因此，有些人通过翻墙的方式来绕过这些限制，以便能够访问被屏蔽的网站和服务。</p>
<p>需要注意的是，翻墙可能违反当地法律法规，并且可能会导致安全和隐私问题。因此，在决定是否翻墙时，需要根据自己的情况权衡利弊，并采取必要的安全措施。 </p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230609013453099.png" alt="image-20230609013453099"></p>
<blockquote>
<p>局域网 &#x3D; 私网 &#x3D; 内网</p>
<blockquote>
<p>局域网：指地理位置相对比较近并且为一个统一 的业务提供一些服务，通常将自己内部构建的网络称之为一个局域网，也叫内网 ，比如：公司内部的网络、家里连一个tp—link的路由器，让手机上网。 </p>
</blockquote>
<p>城域网：在一个城市范围之内的网络，城市内的设备互联，称之为城域网。</p>
<p>广域网：提供全世界范围内的设备的互联，称之为广域网</p>
<blockquote>
<p>现在有些地方和教材会把城域网和广域网进行合并，统称为广域网，因为一个城域网内，是多个局域网进行互联，是要接入运营商的， 只要接入了运营商的网络都可以称之为广域网，<strong>反之，如果整体数据的流量不经过广域网，只在一个内部的网络里流通，那么就是一个相对范围内的局域网。</strong></p>
</blockquote>
</blockquote>
<blockquote>
<p>无线网络传输有不稳定的现象，比如频繁的移动设备或者距离太远或者中间有一些介质的干扰都会造成信号的紊乱。</p>
<p>有线网络传输有链路本身不稳定或者网线离一些强电设备比较近，比如电源线、冰箱、电磁炉都会收到干扰</p>
<blockquote>
<p><strong>当设备之间进行数据传输时，中间的传输介质正好经过强电设备，此时就有可能导致数据传输出现问题，也就是数据传错了。</strong></p>
</blockquote>
</blockquote>
<p><strong>OSI七层模型解析：</strong></p>
<blockquote>
<p><strong><code>物理层的作用：</code></strong> **<code>去规范传输介质的标准（传输介质：设备与设备之间相连的网线或者光纤）</code>**，比如 设备间要进行互联，中间要用一根网线，网线要做水晶头以及要按照什么样的顺序去做，这个标准是由物理层制定的，那么这就是物理层的功能 。</p>
<blockquote>
<p><strong>在物理层，当数据在传输的过程中出现了问题，就没必要再往下转发了，但是在物理层是没有检测机制的（其实就是网线无法提供检测机制），无法校验数据，无法判断数据该不该转发，所以下层解决不了的问题，交给上层。</strong></p>
</blockquote>
<p><strong><code>数据链路层的作用：</code></strong> **<code>进行差错检测，但是不能纠错。</code>**比如：pc将数据发送到某个设备上，那么这个设备是可以进行校验的，通过校验，检查传输的过程中有没有产生错误的数据，若产生错误的数据，则直接将数据丢掉</p>
<blockquote>
<p><strong>数据传输过程中，会携带数据链路层的地址信息，叫做MAC地址，会进行相对应的数据封装以及数据的标识</strong></p>
<p>**数据链路层的功能只能局限于一个小型的内部网络中，由MAC地址（标识）进行数据的转发，面向全世界转发数据是不能的，比如一个pc跨越很远的距离到达另一台pc是做不到的 ，所以数据链路层做不到就交给网络层进行处理 **</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230610020302114.png" alt="image-20230610020302114"></p>
<p><strong>全局的概念：网络层也有一个地址信息（IP地址），这个地址信息的生效地点不是在一个小型的内部网络中，而是在报文传递的全部过程（全局范围内），也就是数据从源设备转发到到目的设备的过程，生效点具体在源设备和目的设备上</strong></p>
<p><strong>链路的概念：pc到达目的地的过程中，要经过许多中间设备，但是每一台设备经过以后，都不会去改变现在的全局的地址信息 ，而每个设备与设备之间叫做链路，都是一个小型的地址范围，是会一直更换的，使用的是MAC地址</strong></p>
<p><strong><code>网络层的作用：</code></strong>  **<code>实现ip地址间（主机到主机间）的通信</code>**，通过IP地址可以在全局的范围内唯一的定位一台设备，其次有相对应的路由功能（数据转发时，会提供相对应的路由，告诉你未来该从那去转发）</p>
<blockquote>
<p><strong><code>路由：你要去往目的地，这条路该怎么走</code></strong></p>
<p>IP地址mac地址协同办公</p>
<p><strong>网络层也没有纠错功能，所以交给传输层处理以及网络层无法实现对一个设备不同应用间的区分</strong></p>
<blockquote>
<p><strong>网络层无法实现对一个设备不同应用间的区分？</strong></p>
<p><strong>比如：一个pc上同时运行了两个软件（QQ和微信），当两个软件分别向各自的服务器发送请求后，服务器回应到pc上，但是pc只有一个ip地址，ip地址仅仅只能标识这个设备在网络中的位置，但是不能够告诉别人我现在用的是什么应用，所以需要上层的传输层解决。</strong>**</p>
</blockquote>
</blockquote>
<p><strong><code>传输层的作用：</code>实现端到端（设备间应用到应用）的通信</strong>，**<code>使用端口来区分应用和基于不同协议可能完成纠错</code>**</p>
<blockquote>
<p>比如：在本地的设备上给QQ和微信随机 分别起一个代号，当进行数据访问时，发送的请求，同时也会携带上代号传给服务器，服务器回应时，会根据代号（端口）找到对应的应用</p>
</blockquote>
<p><strong><code>TCP：可靠传输协议（可以纠错）</code></strong></p>
<p><strong><code>UDP：不可靠传输协议（无法纠错）</code></strong></p>
<blockquote>
<p><strong><code>在传输层选择了某种可靠的传输协议，是可以完成纠错的</code></strong></p>
</blockquote>
<p>一个软件可以实现很多种不同的服务 </p>
<blockquote>
<p><strong>传输层可以定位到不同的应用，但是具体的应用服务是办不到的，没有办法进行区分，需要交给上一层会话层解决</strong></p>
</blockquote>
<blockquote>
<p><strong><code>总结：实际上，我们作为网络工程师，更关心数据能不能到达对方设备上，至于数据到达对端之后，找那个应用软件，找那个应用软件中的具体哪个服务我们是不需要关心的，我们只关心网络中数据是否能够转发到对方设备上</code></strong></p>
</blockquote>
<p><strong><code>会话层的作用：</code>实现应用内不同服务进程和服务进程间的通信</strong></p>
<blockquote>
<p>基于应用内不同的服务是由软件工程师开发、设计以及定义的 </p>
</blockquote>
<p><strong><code>表示层的作用：负责数据的解码、编译</code></strong></p>
<blockquote>
<p>比如：两台<strong>不同的系统设备上</strong>的两个应用进行数据通信时，由于系统底层原理的实现是不一样的，所以需要通过表示层进行数据的解码和编译</p>
</blockquote>
<p><strong><code>应用层的作用：解决下面模型无法解决的问题，产生不同的数据，验证和加密数据</code></strong></p>
<blockquote>
<p><strong>比如：网络出现问题时，在微信上正好给朋友发信息，导致信息没有成功发送，需要自己手动点击红色感叹号，进行重新发送，这就是应用级别的纠错，像QQ和微信单对单的私聊来说，采用的形式就是UDP，因为在传输层没有纠错，最终交给应用层解决，</strong></p>
</blockquote>
</blockquote>
<p><strong>TCP&#x2F;IP模型解析：</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230614021540924.png" alt="‘"></p>
<h2 id="2、数据封装-传输介质"><a href="#2、数据封装-传输介质" class="headerlink" title="2、数据封装+传输介质"></a>2、数据封装+传输介质</h2><h3 id="数据传输的形式"><a href="#数据传输的形式" class="headerlink" title="数据传输的形式"></a><strong>数据传输的形式</strong></h3><blockquote>
<p><strong>数据传输的形式：</strong></p>
<ul>
<li><p>电路交换</p>
<blockquote>
<p>缺点：电路交换的用户始终占用端到端的通信资源，其他用户就不能使用，宝贵的通信线路资源白白被浪费，导致线路传输效率很低</p>
</blockquote>
</li>
<li><p>报文交换</p>
<blockquote>
<p>在数据之外，加上能够标识接受者以及发送者的信息</p>
</blockquote>
</li>
<li><p><strong>分组交换</strong>（是目前使用最多的交换形式 ，也是最主流的交换形式）</p>
<blockquote>
<p>依然进行报文交换，不过分组交换将每个数据的大小进行限制</p>
</blockquote>
</li>
</ul>
</blockquote>
<h3 id="数据的封装过程"><a href="#数据的封装过程" class="headerlink" title="数据的封装过程"></a><strong>数据的封装过程</strong></h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230616011804820.png" alt="image-20230616011804820"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230616012032256.png" alt="image-20230616012032256"></p>
<blockquote>
<p><strong><code>从上到下是封装，从下到上是解封装</code></strong></p>
<p><strong>数据封装最终会抵达到物理层的网口（网卡），将数据转换为比特流，通过传输介质将数据（二进制形式的数据）推送出去</strong></p>
<p><strong>发送端的网卡把磁盘中的数据转换成网线上的比特流或者电信号；对端的网卡收到比特流再转换成数据</strong></p>
<p><strong><code>报头的作用：每层的作用是通过报头实现的</code></strong></p>
<p><strong><code>数据链路层相对比较特殊，需要加报头（帧头）和报尾（帧尾）</code></strong></p>
</blockquote>
<h3 id="中间网络数据传输"><a href="#中间网络数据传输" class="headerlink" title="中间网络数据传输"></a><strong>中间网络数据传输</strong></h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230616023542653.png" alt="image-20230616023542653"></p>
<blockquote>
<p>S：交换机（switch）</p>
<p>R：路由器（router）</p>
<p><strong><code>交换机的权限最高到数据链路层，也就是工作在二层</code></strong></p>
<p><strong><code>路由器的权限最高到网络层，也就是工作在三层</code></strong></p>
</blockquote>
<h3 id="数据的解封装过程"><a href="#数据的解封装过程" class="headerlink" title="数据的解封装过程"></a><strong>数据的解封装过程</strong></h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230616024948760.png" alt="image-20230616024948760"></p>
<h3 id="简单网络的组成"><a href="#简单网络的组成" class="headerlink" title="简单网络的组成"></a>简单网络的组成</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230616173559647.png" alt="image-20230616173559647"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230616173340700.png" alt="image-20230616173340700"></p>
<blockquote>
<p><strong><code>一个简单的网络必须具体三要素：</code></strong></p>
<ul>
<li>网线</li>
<li>网卡</li>
<li>协议栈</li>
</ul>
</blockquote>
<h3 id="常见传输介质"><a href="#常见传输介质" class="headerlink" title="常见传输介质"></a><strong>常见传输介质</strong></h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230616174153480.png" alt="image-20230616174153480"></p>
<blockquote>
<p><strong><code>传输介质的作用：</code></strong></p>
<ul>
<li>实现设备间的连接</li>
<li>实现数据的传输</li>
</ul>
<p>网线 &#x3D; 双绞线</p>
<p>双绞线的材质是铜</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230705011507442.png" alt="image-20230705011507442"></p>
<p>一般情况下都是采用568B标准（568B和568A没有本质的区别）</p>
<p>同轴电缆（现在已经不使用它组建一个网络了，已经成为历史，取而代之的是双绞线）的应用场景：比较老的有线电视、模拟视频监控</p>
</blockquote>
<blockquote>
<p><strong><code>冲突域：在一定的范围内，数据在发送/接受的过程中，会产生数据的碰撞/冲突</code></strong></p>
<p>一个共享型网络就是一个冲突域（我们需要用到一个叫CSMA&#x2F;CD的机制来进行冲突的避免）</p>
<p><strong><code>CSMA/CD：载波侦听多路访问/冲突检测技术（现在已经没有这个技术的使用场景了，已经被取代了）</code></strong></p>
<p>CSMA&#x2F;CD的几种工作模式：</p>
<ul>
<li>先听后发</li>
<li>边发边听</li>
<li>冲突停发</li>
<li>随机延迟后重发</li>
</ul>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230705011945227.png" alt="image-20230705011945227"></p>
<blockquote>
<p>10BASE-T：10表示传输速率、BASE表示数据传输的形式、T代表现在传输的介质是双绞线、F代表光纤</p>
<p>总结：</p>
<blockquote>
<p><strong><code>对于双绞线我们主要记忆如下几个点：</code></strong></p>
<ul>
<li>双绞线的最长有效传输距离是100米</li>
<li>双绞线的线序</li>
<li>在以太网标准下，双绞线能够实现的最快传输速率是1000M&#x2F;S</li>
</ul>
</blockquote>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230705014033511.png" alt="image-20230705014033511"></p>
<blockquote>
<p><strong><code>半双工 = 对讲机</code></strong></p>
<p><strong><code>全双工 = 打电话</code></strong></p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230705014702509.png" alt="image-20230705014702509"></p>
<blockquote>
<p>光纤是通过光的折射代表光信号</p>
<p><strong><code>广域网更多使用的是光纤</code></strong></p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230705015638837.png" alt="image-20230705015638837"></p>
<h2 id="3、数据链路层与MAC地址"><a href="#3、数据链路层与MAC地址" class="headerlink" title="3、数据链路层与MAC地址"></a>3、数据链路层与MAC地址</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230709213444804.png" alt="image-20230709213444804"></p>
<blockquote>
<p><strong><code>如果数据进行封装时，基于E2或者802.3标准，此时我们称之为是一个以太网数据帧。</code></strong></p>
<p><strong><code>E2（Ethernet2）和802.3（IEEE 802.3）作用：定义帧头和帧尾的格式。</code></strong></p>
<p><strong><code>目前整个局域网中，以太网（有两种封装标准：E2和802.3）是唯一标准</code></strong></p>
<p><strong><code>在整个广域网中：PPP和HDLC作为两种封装标准 </code></strong></p>
<p><strong>注：</strong></p>
<ul>
<li><p><strong><code>E2、802.3、PPP和HDLC都作为数据链路层的封装标准，只是在不同网络中，用到的封装标准不同。</code></strong></p>
</li>
<li><p>在HCIA阶段中，广域网作为了解即可，局域网作为学习重点。</p>
</li>
</ul>
</blockquote>
<blockquote>
<p><strong><code>数据：对于下层的每个层级而言，上层所反馈或者传递给下层的信息，下层认为皆是数据。</code></strong></p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230711005503890.png" alt="image-20230711005503890"></p>
<blockquote>
<p><strong><code>E2封装标准下的数据帧结构：</code></strong></p>
<ul>
<li><p>FCS：帧校验序列</p>
<blockquote>
<p>会通过一个叫CRC循环冗余校验算法校验整体信息。</p>
</blockquote>
</li>
<li><p>Type：类型</p>
<blockquote>
<p>用于标识上层的协议。</p>
</blockquote>
</li>
<li><p>D.MAC：目的mac，接受者的mac信息</p>
</li>
<li><p>S.MAC：源mac，发送者的mac信息</p>
</li>
</ul>
<p>mac地址 &#x3D; 物理地址 &#x3D; 网卡地址（每个设备出厂时，会烧录进网卡芯片中，出厂自带）</p>
<p>每个网卡或三层网口都有一个 <strong>MAC 地址</strong>， MAC 地址是烧录到硬件上，因此也称为<strong>硬件地址</strong>。MAC 地址作为数据链路设备的地址标识符，需要保证网络中的每个 MAC 地址都是<strong>唯一</strong>的，才能正确识别到数据链路上的设备。</p>
<p>E2封装完成后数据帧的长度：最小为64B，最大为1518B</p>
<p><strong>注：现在以太网中主流E2</strong></p>
</blockquote>
<blockquote>
<p>发送者的动作：</p>
<p>发送者填充源目mac信息，type字段（标识上层协议），以及CRC循环冗余检验，计算除了FCS字段外的其他字段的数值，将数值填充至FCS，信息都填充完毕之后，此时借助物理层，转变为二进制比特流，从链路中传递。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230711222132877.png" alt="image-20230711222132877"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230712002922122.png" alt="image-20230712002922122"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230712001313931.png" alt="image-20230712001313931"></p>
<p>数据抵达接受端端口以后，接受者的动作：</p>
<ol>
<li>首先看目的MAC是否是自己的mac，如果不是丢弃，如果是，则进行下一步；</li>
<li>将数据也进行CRC循环冗余校验，比对FCS里的字段里的数值，如果不同，则丢弃，如果相同，则进行下一步</li>
<li>查看type字段，交由type字段标识的上层协议处理</li>
<li>数据链路层工作结束</li>
</ol>
</blockquote>
<blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230712000841061.png" alt="image-20230712000841061"></p>
<p><strong><code>MTU：最大传输单元（不包含数据链路层的封装，指的是网络层及以上的数据封装，我们称之为MTU，即在数据链路层里的DATA字段（数据）的最大存储容量）</code><strong>，在802.3封装标准中，MTU的范围是38~1492字节，在E2封装标准中，MTU的范围是46 ~ 1500（</strong>注：MTU默认值是1500</strong>）</p>
<blockquote>
<p>在链路上，如果报文的MTU过大， 而链路所能承载的MTU值过小，则可能导致数据分片或者数据丢弃。</p>
</blockquote>
</blockquote>
<blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230712000436965.png" alt="image-20230712000436965"></p>
<p>当一个设备收到数据帧，是通过上述的type或者length字段的数值判断使用了那个封装标准</p>
</blockquote>
<h2 id="4、MAC地址-网络层"><a href="#4、MAC地址-网络层" class="headerlink" title="4、MAC地址+网络层"></a>4、MAC地址+网络层</h2><h3 id="mac地址"><a href="#mac地址" class="headerlink" title="mac地址"></a>mac地址</h3><blockquote>
<p>二进制（逢二进一）</p>
<p>0&#x3D;0</p>
<p>1&#x3D;1</p>
<p>10&#x3D;2</p>
<p>11&#x3D;3</p>
<p>100&#x3D;4</p>
<p>101&#x3D;5</p>
<p>110&#x3D;6</p>
<p>111&#x3D;7</p>
<p>1000&#x3D;8</p>
<p>1001&#x3D;9</p>
<p>1010&#x3D;10</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230712223508088.png" alt="image-20230712223508088"></p>
<blockquote>
<p><strong><code>Ox：用来标识16进制</code></strong></p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230712223027619.png" alt="image-20230712223027619"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230712225222350.png" alt="image-20230712225222350"></p>
<blockquote>
<p><strong><code>二进制和十六进制之间的关系：1个16进制可以用4个二进制表示，1:4的关系</code></strong></p>
<p><strong><code>一个十进制数对应一个字节或者对应8个比特位</code></strong></p>
</blockquote>
</blockquote>
<blockquote>
<p>MAC地址的概念：</p>
<ol>
<li><p>单播：通信形式上，点对点，单对单的通信，类似与qq私聊。</p>
<p>单播mac地址：从高位向低位（从左往右）第8位为0，且一定为0，其他任意。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230712233530730.png" alt="image-20230712233530730"></p>
<p>数据封装时，源mac和目的mac都是单播mac，则为单播通信。（<strong>注：在网卡上的mac地址都是单播地址。</strong>）</p>
</li>
<li><p>组播：通信形式上，点对多点，单对多的通信，类似于qq群聊。</p>
<p>组播mac地址：从高位向低位（从左往右）第8位为1，且一定为1，其他任意。</p>
<p>数据封装时，因为组播代表的是一组的集合，面向一组的通信，此时组播mac不能成为数据的源地址，仅能充当目的地址。</p>
</li>
<li><p>广播：通信形式上，点对所有，单对所有的通信。广而播之&#x2F;强制的接受处理。</p>
<p>数据封装时，因为广播代表的是所有人的集合，面向所有人的通信，此时广播mac不能成为数据的源地址，仅能充当目的地址。</p>
<p><strong><code>广播mac地址：从高位向低位48位全部为1，且一定为1。也可以表示成16进制全F。</code></strong></p>
</li>
</ol>
</blockquote>
<blockquote>
<p>a：目的mac为单播mac</p>
<p>b：目的mac为组播mac</p>
<p>c：目的mac为广播mac</p>
<p>发送者的动作：</p>
<p>发送者填充源目mac信息，type字段（标识上层协议），以及CRC循环冗余检验，计算除了FCS字段外的其他字段的数值，将数值填充至FCS，信息都填充完毕之后，此时借助物理层，转变为二进制比特流，从链路中传递。</p>
<p>a场景：</p>
<p>单播数据抵达接受端端口以后，接受者的动作：</p>
<ol>
<li>首先看目的MAC是否是自己的mac，如果不是丢弃，如果是，则进行下一步；</li>
<li>将数据也进行CRC循环冗余校验，比对FCS里的字段里的数值，如果不同，则丢弃，如果相同，则进行下一步</li>
<li>查看type字段，交由type字段标识的上层协议处理</li>
<li>数据链路层工作结束</li>
</ol>
<p>b场景：</p>
<p>组播数据抵达接受端端口以后，接受者的动作：</p>
<ol>
<li>首先看目的MAC，查看自己本地是否加组，如果没加组丢弃，如果加组 ，则进行下一步；</li>
<li>将数据也进行CRC循环冗余校验，比对FCS里的字段里的数值，如果不同，则丢弃，如果相同，则进行下一步</li>
<li>查看type字段，交由type字段标识的上层协议处理</li>
<li>数据链路层工作结束</li>
</ol>
<p>c场景：</p>
<p>广播数据抵达接受端端口以后，接受者的动作：</p>
<ol>
<li>首先看目的MAC，如果是广播，则直接进行下一步；</li>
<li>将数据也进行CRC循环冗余校验，比对FCS里的字段里的数值，如果不同，则丢弃，如果相同，则进行下一步</li>
<li>查看type字段，交由type字段标识的上层协议处理</li>
<li>数据链路层工作结束</li>
</ol>
</blockquote>
<h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230713003446514.png" alt="image-20230713003446514"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230713003828298.png" alt="image-20230713003828298"></p>
<h2 id="5、VLAN"><a href="#5、VLAN" class="headerlink" title="5、VLAN"></a>5、VLAN</h2><p><strong><code>交换机原理：</code></strong></p>
<blockquote>
<p><strong><code>主机A想要访问主机B，通过子网掩码判断是否是同一网段，如果是，则主机A发送一条以广播形式的ARP请求包（源mac：A的mac地址；目mac：全F），交换机收到后，将ARP请求包里的目标 MAC 地址与交换机里的MAC 地址表进行匹配，发现并没有对应的匹配，交换机会通过自动学习，将端口收到的ARP请求包的源mac和端口号记录到mac地址表中并且将ARP请求包除了接受端口外的其他端口进行泛洪，主机B收到ARP包后，发现目的MAC为全F的广播包与自己有关系，拆开外层的目的MAC，发现内层的目的IP与自己的IP对应，于是主机B回复一条ARP应答包（源mac：B的mac地址；目mac：A的mac地址），交换机收到后，将端口收到的ARP应答包里的源MAC地址和端口号记录到mac地址表中，以单播的形式发送给主机A，主机A收到ARP应答包后，将B的MAC地址填充到数据帧的目的MAC中，完成数据的封装，就可以进行数据的转发通信了。</code></strong></p>
</blockquote>
<p><strong><code>交换的作用：</code></strong></p>
<blockquote>
<ol>
<li>封装目的mac地址（没有目的mac地址是无法进行通信的）</li>
<li>连接设备</li>
</ol>
</blockquote>
<blockquote>
<p>自动学习：</p>
<p>记录端口收到数据的源mac和端口号</p>
<p>收到单播数据帧，查看mac地址表，是否存在对应关系</p>
<ul>
<li>若不存在，则泛洪（未知单播数据帧——BUM）</li>
<li>若存在，则转发</li>
</ul>
<p>报文学习 &#x3D; 动态mac地址表 &#x3D; 300s &#x3D; 老化时间 &#x3D; 5分钟</p>
<p>ARP表 &#x3D; 20分钟</p>
<ul>
<li><p><strong><code>IP和MAC的对应关系</code></strong></p>
</li>
<li><p>作用：用于通信设备进行数据封装</p>
</li>
<li><p>存在：任何要封装数据的设备</p>
</li>
</ul>
<p>MAC地址表 &#x3D; 5分钟</p>
<ul>
<li><p>mac地址和端口的对应关系</p>
</li>
<li><p>作用：用于交换机中转发数据</p>
</li>
<li><p>存在：交换机中</p>
</li>
</ul>
<p>接受方向（pc发送数据给交换机的某个端口，该端口我们称为接受方向）：不会进行tag剥离&#x2F;弹出</p>
<p>发送方向（交换机从某个端口将数据转发出去，该端口我们称为发送方向）：会进行tag剥离&#x2F;弹出</p>
<p>交换机内部处理的都是带tag的数据帧</p>
<p>链路类型&#x2F;接口类型：</p>
<p>access、trunk、hybrid</p>
<p>PVID &#x3D; 缺省vlan &#x3D;交换机所有接口默认属于vlan 1 &#x3D; 接口 vlan</p>
<p>三种接口类型：</p>
<ol>
<li><p>access——接入类型</p>
<blockquote>
<ul>
<li>不带vlan标签的数据，“空白”的数据帧</li>
<li>一个access接口只能属于一个vlan</li>
<li>对于交换机的泛洪：会向除了接受端口之外，其他能够转发本vlan的端口进行泛洪。</li>
</ul>
</blockquote>
</li>
<li><p>trunk——干道类型</p>
<blockquote>
<p>列表：vlan允许通过的列表   &#x2F;&#x2F; 通过的前提：保证存在该vlan</p>
<p>特点：同时允许多个不同vlan通过</p>
</blockquote>
</li>
<li><p>hybrid——杂合类型&#x2F;混杂&#x2F;混合</p>
</li>
</ol>
</blockquote>
<blockquote>
<p>通过access和trunk模式可以实现两种需求：</p>
<ol>
<li><p>通过access能实现同交换机不同vlan不同</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230715180019869.png" alt="image-20230715180019869"></p>
</li>
<li><p>通过access和trunk相结合能实现不同交换机同vlan互通</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230715175251769.png" alt="image-20230715175251769"></p>
</li>
</ol>
</blockquote>
<blockquote>
<p><strong><code>VLAN的形成的最根本原因就是缩小广播域，目的是提高安全性，当没有使用VLAN划分时，不管是相同网段之间或者不同网段之间都属于同一个广播域，不同网段是不能隔离广播域的</code></strong></p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230716010010068.png" alt="image-20230716010010068"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230716011836181.png" alt="image-20230716011836181"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230716012854085.png" alt="image-20230716012854085"></p>
<h2 id="6、DHCP原理与配置"><a href="#6、DHCP原理与配置" class="headerlink" title="6、DHCP原理与配置"></a>6、DHCP原理与配置</h2><blockquote>
<p>DHCP作用：为主机分配地址参数</p>
<p>ipconfig &#x2F;all：查设备上所有的网卡命令</p>
<p>网络地址（网段）是通过ip地址配合子网掩码来判断的</p>
<p>默认网关：跨网段时使用默认网关，负责接受跨网段的数据转发</p>
<p><strong><code>DNS服务器：提供域名解析服务（DNS就是把域名解析为IP地址，提供我们上网，我们能够上网最终是找到IP地址），当一台pc与 DNS服务器对应时，全球的DNS服务器都会同步</code></strong></p>
<p><strong><code>当一台pc通过目的IP访问百度之前时，不是直接访问百度的服务器，而是先访问DNS服务器进行域名解析，然后再访问百度的服务器</code></strong></p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230714105435271.png" alt="image-20230714105435271"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230714105904826.png" alt="image-20230714105904826"></p>
<blockquote>
<ol>
<li><p>客户端以广播的形式发送一个DHCP发现报文到中继设备上，（DHCP DISCOVER）</p>
<blockquote>
<p><strong><code>1、客户端发送到dhcp中继设备上的dhcp discover报文的封装内容为：源ip是0.0.0.0，目的ip是255.255.255.255，源mac地址是客户端的mac地址，目的mac地址是全F</code></strong></p>
<p><strong><code>2、dhcp中继设备重新封装dhcp discover报文的内容：源ip是dhcp中继设备发送接口的ip地址，目的ip是dhcp服务器地址，源mac地址是发送接口的mac地址，目的mac地址是服务器的mac地址</code></strong></p>
</blockquote>
</li>
</ol>
<p>​          客户端发送的DHCP发现报文的源目IP：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230714110414730.png" alt="image-20230714110414730"></p>
<ol start="2">
<li><p>DHCP服务器以单播或者广播的形式回复一个DHCP响应报文（DHCP OFFER）</p>
<p><strong>注：华为使用单播；思科和Windows使用广播</strong></p>
</li>
<li><p>客户端以广播的形式发送一个DHCP请求确认报文（DHCP REQUEST）</p>
<p><strong>注：当租期更新时，发送的DHCP REQUEST报文是单播的形式</strong></p>
</li>
<li><p>DHCP服务器以广播或者单播的形式回复一个确认响应报文</p>
</li>
</ol>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230714112514048.png" alt="image-20230714112514048"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230714113408698.png" alt="image-20230714113408698"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230714113513461.png" alt="image-20230714113513461"></p>
<p><strong>DHCP补充：</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230730101712490.png" alt="image-20230730101712490"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230730101908156.png" alt="image-20230730101908156"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230730103552368.png" alt="image-20230730103552368"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230730104947826.png" alt="image-20230730104947826"></p>
<blockquote>
<p><strong><code>dhcp服务器有多个地址池，服务器如何判断应分配给主机的是哪个地址池中的地址?</code></strong></p>
<p>通过地址池中的网关</p>
</blockquote>
<blockquote>
<p><strong><code>交换机与路由器连接的其中一个端口配置为access，在access模式上划分vlan并且在vlan上配置地址或者在交换机上开启三层功能（三层交换机默认的三层功能是关闭的），就可以直接配ip地址。</code></strong></p>
</blockquote>
<blockquote>
<p><strong><code>路由器的接口为e口的是不能直接配置ip地址，解决办法是直接换台其他类型的路由器或者创建vlan，在access模式的vlan上配置ip地址。</code></strong></p>
</blockquote>
<blockquote>
<p>随机值的作用：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230730122522401.png" alt="image-20230730122522401"></p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230730122747623.png" alt="image-20230730122747623"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230730123758059.png" alt="image-20230730123758059"></p>
<h2 id="7、NAT"><a href="#7、NAT" class="headerlink" title="7、NAT"></a>7、NAT</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230715122524971.png" alt="image-20230715122524971"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230715150728280.png" alt="image-20230715150728280"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230715150758199.png" alt="image-20230715150758199"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230715145941421.png" alt="image-20230715145941421"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230715150214066.png" alt="image-20230715150214066"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230715150631723.png" alt="image-20230715150631723"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230715151337708.png" alt="image-20230715151337708"></p>
<h2 id="8、PPPOE"><a href="#8、PPPOE" class="headerlink" title="8、PPPOE"></a>8、PPPOE</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230715162325845.png" alt="image-20230715162325845"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230715163058895.png" alt="image-20230715163058895"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230715163125254.png" alt="image-20230715163125254"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230715163202594.png" alt="image-20230715163202594"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230715163336990.png" alt="image-20230715163336990"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230715163352571.png" alt="image-20230715163352571"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230715163409227.png" alt="image-20230715163409227"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230715163426475.png" alt="image-20230715163426475"></p>
<h2 id="9、ensp中的基本命令"><a href="#9、ensp中的基本命令" class="headerlink" title="9、ensp中的基本命令"></a>9、ensp中的基本命令</h2><blockquote>
<p>？&#x3D; 当前可以配置的命令 </p>
<p>system-view &#x3D; 从用户视图到系统视图 </p>
<p>Tab &#x3D; 输入命令时，按tab自动补全 以该字母为开头的命令 </p>
<p>回车 &#x3D; 输入一个命令，想要生效，敲回车 </p>
<p>Quit &#x3D; 从当前视图返回上一个视图 </p>
<p>简写 &#x3D; 如果此时该命令唯一，此时可以使用简写 </p>
<p>Ctrl+Z &#x3D; 从当前视图直接退回用户视图 </p>
<p>Sysname &#x3D; 改设备名 </p>
<p>Brief &#x3D; 摘要&#x2F;重点 </p>
<p>display ip interface brief &#x3D; 查看接口地址以及状态的信息</p>
<p>display this &#x3D; 查看当前视图下的配置</p>
<p>interface GigabitEthernet 0&#x2F;0&#x2F;1 &#x3D; 进入设备接口</p>
<p>Undo &#x3D; 删除命令&#x2F;关闭功能</p>
<p>display current-configuration &#x3D; 查看设备当前配置 -dis cu</p>
<p>Save &#x3D; 保存配置</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230716114728116.png" alt="image-20230716114728116"></p>
<p>上述视图中：</p>
<ul>
<li>配置地址时，使用空格键实现两个字节之间的切换</li>
<li>使用tab键实现换行</li>
</ul>
</blockquote>
<h2 id="10、设备管理（对设备进行命令配置）"><a href="#10、设备管理（对设备进行命令配置）" class="headerlink" title="10、设备管理（对设备进行命令配置）"></a>10、设备管理（对设备进行命令配置）</h2><blockquote>
<p><strong><code>设备管理分为三种：</code></strong></p>
<ol>
<li><p>通过PC的USB接口与设备的console接口连接，实现对设备的本地管理（对设备进行命令配置）</p>
</li>
<li><p>通过telnet，实现对远程设备的管理</p>
<blockquote>
<p>telnet分为两种模式：</p>
<ol>
<li>基于无用户的密码登录模式，只需要设置密码，通过密码登录实现对远程设备的管理</li>
<li>基于用户的密码登录模式，需要设置用户名和密码，通过用户名和密码登录实现对远程设备的管理</li>
</ol>
<p><strong><code>注：telnet并不安全，因为在链路上传输的是明文，容易被别人抓包，获取到密码</code></strong></p>
</blockquote>
</li>
<li><p>通过SSH，实现对远程设备的管理，比telnet安全</p>
</li>
</ol>
</blockquote>
<h2 id="11、路由"><a href="#11、路由" class="headerlink" title="11、路由"></a>11、路由</h2><blockquote>
<p><strong><code>路由表：路由器寻址转发时查询路由表，根据路由进行具体的转发</code></strong></p>
<p>路由表的形成：</p>
<ol>
<li><p>直连路由（direct）</p>
<blockquote>
<ul>
<li><p>是根据本网络的直连的接口信息产生的</p>
<p>配置了接口地址后会产生网络地址（网段）+定向广播地址+当前接口的网关地址（主机路由，用于未来访问本设备时，进行转发）信息</p>
</li>
<li><p>接口处于up状态 [物理状态&#x3D;连接设备通电]  以及配置IP地址</p>
</li>
<li><p>接口物理状态为up，则直连路由存在；物理状态为down，则直连路由不存在</p>
</li>
</ul>
</blockquote>
</li>
<li><p>静态路由</p>
</li>
<li><p>动态路由</p>
</li>
</ol>
<p><strong><code>本地广播与定向广播的区别：</code></strong></p>
<ul>
<li>本地广播地址：全F</li>
<li>定向广播地址：主机号为全1，比如：12.3.3.255（掩码为24）</li>
<li>定向广播能在同网段转发，在不同网段不能转发</li>
<li>本地广播：能在相同和不同网段转发</li>
<li>路由器隔离本地广播，不能隔离定向广播</li>
</ul>
</blockquote>
<blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230716175718454.png" alt="image-20230716175718454"></p>
<p><strong>路由表参数：</strong></p>
<p>协议（proto）：标识前方的目的网络是通过什么协议形成的。</p>
<p>优先级（pre）：代表形成路由的协议的优先级数值。</p>
<p>开销值（cost）：代表该路由协议形成此路由时候的开销 - [不同的路由协议计算方式不一样]</p>
<p>下一跳（plags nexthop）：数据离开本路由器需要抵达的地址</p>
<p>出接口（interface）：去往下一跳地址，要从本地哪个接口发出去 - 接口编号。</p>
<p><strong>路由的加表：</strong></p>
<p>如果目的网络及掩码信息不一致，则都会加表；如果一致，才会触发比较。</p>
<p>路由器选择最优的路由加入到路由表中 &gt; 最优加表 &#x3D; 如何衡量最优呢？</p>
<p>1.比较形成路由的优先级数值，越小越优。</p>
<p>2.如果优先级相同的情况下，比较开销值，越小越优。</p>
<p>3.如果cost相同的情况下，此时多条路由则都会加表 &#x3D;&#x3D; <strong>等价路由</strong></p>
<p>开销值的比较仅仅可以在同一协议下比较，不同协议由于计算开销值的方式不同，所以不具备比较能力。</p>
<p>直连路由或者静态路由的cost值都为0</p>
<p>**<code>静态路由：</code>**ip route-static 目的网段 + 目的网段掩码 + 下一跳IP地址</p>
<p><strong>路由的查表原则：</strong>最长掩码匹配原则</p>
<p>本地有多个匹配的路由，会按照掩码最长的转发。</p>
<p><strong><code>如果有一条路由，目的地和掩码全部为0，则代表默认路由（缺省路由），匹配所有目的IP地址，不管目的ip地址是多少，都走下一跳</code></strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230731010136900.png" alt="image-20230731010136900"></p>
<p>注意：该路由掩码为0，则为匹配顺序最劣的路由，本地无路由可以匹配，才会考虑默认。</p>
<p><strong>静态路由加表原则：</strong></p>
<p>保证下一跳地址能够顺利通过某个出接口抵达即可 —— 下一跳可达。</p>
<p>如何衡量下一跳是否可达，看本地是否有去往目的网段的路由。</p>
<p><strong><code>路由器转发数据时，源目MAC会重新封装，以出接口的mac为源mac，下一跳的mac为目的mac。</code></strong></p>
<p><strong><code>设备是否能够实现通信：看本设备是否有去往目的网段的路由，有则转发，无则不转发。</code></strong></p>
</blockquote>
<h2 id="12、ICMP"><a href="#12、ICMP" class="headerlink" title="12、ICMP"></a>12、ICMP</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230727194915733.png" alt="image-20230727194915733"></p>
<blockquote>
<p>ICMP：网络层协议，3.5层</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230718214239627.png" alt="image-20230718214239627"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230727154306344.png" alt="image-20230727154306344"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230727200028191.png" alt="image-20230727200028191"></p>
<blockquote>
<p>发送了5组的icmp报文</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230727200329872.png" alt="image-20230727200329872"></p>
<blockquote>
<p>Tracert：路由追踪</p>
</blockquote>
<h2 id="13、FTP传输文件"><a href="#13、FTP传输文件" class="headerlink" title="13、FTP传输文件"></a>13、FTP传输文件</h2><blockquote>
<p>传输工作：</p>
<ol>
<li><p>客户端找服务器建立tcp连接（控制连接）</p>
<p>控制连接：</p>
<ul>
<li>控制连接中不传输文件</li>
<li>控制连接目的是协商一些双方的约束</li>
</ul>
</li>
<li><p>在控制连接的指导下建立数据连接，才能传输文件（业务数据）；</p>
<p>数据连接可以是主动模式</p>
<ul>
<li>服务器主动找客户端建立数据连接</li>
</ul>
<p>数据连接可以是被动模式</p>
<ul>
<li>客户端主动找服务器建立连接</li>
</ul>
</li>
<li><p>文件传输完毕，断开数据连接和控制连接</p>
</li>
</ol>
</blockquote>
<h2 id="14、STP"><a href="#14、STP" class="headerlink" title="14、STP+"></a>14、STP+</h2><h3 id="什么是STP？"><a href="#什么是STP？" class="headerlink" title="什么是STP？"></a>什么是STP？</h3><p>STP（Spanning Tree Protocol）是一个用于局域网中消除环路的协议，它的标准是IEEE 802.1D。STP通过将部分冗余链路强制为阻塞状态，其他链路处于转发状态，将环形网络结构修剪成无环路的树形网络结构，可实现消除环路。当处于转发状态的链路不可用时，STP重新配置网络，并激活合适的备用链路状态，恢复恢复网络连通性。</p>
<p><strong>目录</strong></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://info.support.huawei.com/info-finder/encyclopedia/zh/STP.html#content1">为什么需要STP</a></li>
<li><a target="_blank" rel="noopener" href="https://info.support.huawei.com/info-finder/encyclopedia/zh/STP.html#content2">STP vs RSTP vs MSTP</a></li>
<li><a target="_blank" rel="noopener" href="https://info.support.huawei.com/info-finder/encyclopedia/zh/STP.html#content3">STP是如何工作的</a></li>
<li><a target="_blank" rel="noopener" href="https://info.support.huawei.com/info-finder/encyclopedia/zh/STP.html#content4">STP的典型应用</a></li>
</ul>
<h3 id="为什么需要STP"><a href="#为什么需要STP" class="headerlink" title="为什么需要STP"></a>为什么需要STP</h3><p>在一个复杂的网络环境中，由于冗余备份的需要，网络设计者都倾向于在设备之间部署多条物理链路，其中一条作主用链路，其他链路作备份，偶然或必然中都会导致环路产生。环路会产生广播风暴，最终导致整个网络资源被耗尽，网络瘫痪不可用。环路还会引起MAC地址表震荡导致MAC地址表项被破坏。</p>
<p>STP技术可以有效的解决环路问题，将彼此交互信息发现网络中的环路，将部分冗余链路强制为阻塞状态，其他链路处于转发状态。最终将环形网络结构修剪成无环路的树形网络结构，从而防止报文在环形网络中不断增生和无限循环，避免设备由于重复接收相同的报文造成处理能力下降。</p>
<h3 id="STP-vs-RSTP-vs-MSTP"><a href="#STP-vs-RSTP-vs-MSTP" class="headerlink" title="STP vs RSTP vs MSTP"></a>STP vs RSTP vs MSTP</h3><p>STP包含两种含义：</p>
<ul>
<li>狭义的STP是指IEEE 802.1D中定义的STP协议。</li>
<li>广义的STP包括IEEE 802.1D中定义的STP、IEEE 802.1W中定义的快速生成树协议RSTP（Rapid Spanning Tree Protocol）和IEEE 802.1S中定义的多生成树协议MSTP（Multiple Spanning Tree Protocol）。</li>
</ul>
<p>目前，生成树协议支持如下：</p>
<ul>
<li>STP是基础的数据链路层的管理协议，用于二层网络的环路检测和预防。但是，STP拓扑收敛速度慢。</li>
<li>RSTP在STP基础上进行了改进，实现了网络拓扑快速收敛。但RSTP和STP还存在同一个缺陷：局域网内所有的<a target="_blank" rel="noopener" href="https://info.support.huawei.com/info-finder/encyclopedia/zh/VLAN.html">VLAN</a>共享一棵生成树，不能按VLAN阻塞冗余链路，所有VLAN的报文都沿着一棵生成树进行转发。</li>
<li>MSTP通过设置VLAN映射表（即VLAN和生成树实例的对应关系表），把VLAN和生成树实例联系起来。同时它把一个交换网络划分成多个域，每个域内形成多棵生成树实例，生成树实例之间彼此独立。MSTP提供了数据转发的多个冗余路径，在数据转发过程中实现VLAN数据的负载均衡。</li>
</ul>
<p>生成树协议中，MSTP兼容RSTP、STP，RSTP兼容STP。三种生成树协议的比较如<a target="_blank" rel="noopener" href="https://info.support.huawei.com/info-finder/encyclopedia/zh/STP.html#table1027518291293">表1-1</a>所示。</p>
<p><strong>表1-1</strong> 三种生成树协议的比较</p>
<table>
<thead>
<tr>
<th>生成树协议</th>
<th>特点</th>
<th>应用场景</th>
</tr>
</thead>
<tbody><tr>
<td>STP</td>
<td>形成一棵无环路的树，解决广播风暴并实现冗余备份。收敛速度较慢。</td>
<td>无需区分用户或业务流量，所有VLAN共享一棵生成树。</td>
</tr>
<tr>
<td>RSTP</td>
<td>形成一棵无环路的树，解决广播风暴并实现冗余备份。收敛速度快。</td>
<td></td>
</tr>
<tr>
<td>MSTP</td>
<td>形成多棵无环路的树，解决广播风暴并实现冗余备份。收敛速度快。多棵生成树在VLAN间实现负载均衡，不同VLAN的流量按照不同的路径转发。</td>
<td>需要区分用户或业务流量，并实现负载分担。不同的VLAN通过不同的生成树转发流量，每棵生成树之间相互独立。</td>
</tr>
</tbody></table>
<h3 id="STP是如何工作的"><a href="#STP是如何工作的" class="headerlink" title="STP是如何工作的"></a>STP是如何工作的</h3><h3 id="STP的基本概念"><a href="#STP的基本概念" class="headerlink" title="STP的基本概念"></a>STP的基本概念</h3><p>从环形网络拓扑结构到树形结构，总体来说有三个要素：根桥、根端口和指定端口。</p>
<p><strong>根桥</strong>：对于一个STP网络，根桥在全网中只有一个，它是整个网络的逻辑中心，但不一定是物理中心。在进行根桥的选择时，一般会选择性能高、网络层次高的交换设备作为根桥。根桥会根据网络拓扑的变化而动态变化。</p>
<p><strong>根端口</strong>：去往根桥路径开销最小的端口，根端口负责向根桥方向转发数据，这个端口的选择标准是依据路径开销判定。在一台设备上所有使能STP的端口中，根路径开销最小者，就是根端口。很显然，在一个运行STP协议的设备上根端口有且只有一个，根桥上没有根端口。</p>
<p><strong>指定端口</strong>：指定桥与指定端口的描述见<a target="_blank" rel="noopener" href="https://info.support.huawei.com/info-finder/encyclopedia/zh/STP.html#table88712561661">表1-2</a>。</p>
<p><strong>表1-2</strong> 指定桥与指定端口的含义</p>
<table>
<thead>
<tr>
<th>分类</th>
<th>指定桥</th>
<th>指定端口</th>
</tr>
</thead>
<tbody><tr>
<td>对于一台设备而言</td>
<td>与本机直接相连并且负责向本机转发配置消息的设备</td>
<td>指定桥向本机转发配置消息的端口</td>
</tr>
<tr>
<td>对于一个局域网而言</td>
<td>负责向本网段转发配置消息的设备</td>
<td>指定桥向本网段转发配置消息的端口</td>
</tr>
</tbody></table>
<p>如<a target="_blank" rel="noopener" href="https://info.support.huawei.com/info-finder/encyclopedia/zh/STP.html#fig197884424011">图1-2</a>所示，AP1、AP2、BP1、BP2、CP1、CP2分别表示设备Device1、Device2、Device3的端口。</p>
<ul>
<li><p>Device1通过端口AP1向Device2转发配置消息，则Device2的指定桥就是Device1，指定端口就是Device1的端口AP1。</p>
</li>
<li><p>与局域网LAN相连的有两台设备：Device2和Device3，如果Device2负责向LAN转发配置消息，则LAN的指定桥就是Device2，指定端口就是Device2的BP2。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://download.huawei.com/mdl/image/download?uuid=7d5e162aac2d4d9495f1d7c0dbb37ff9" alt="指定桥与指定端口示意图"><br><em>指定桥与指定端口示意图</em></p>
</li>
</ul>
<p>此外，设备和端口都有ID，分别是桥ID（BID）和端口ID（PID）。端口ID由端口优先级和端口号组成。桥ID由桥优先级和桥MAC两部分组成，在STP网络中，桥ID最小的设备会被选举为根桥。</p>
<h3 id="STP的实现过程"><a href="#STP的实现过程" class="headerlink" title="STP的实现过程"></a>STP的实现过程</h3><p>STP的基本实现过程如下：</p>
<ol>
<li>选择根网桥：网络初始化时，网络中所有的STP设备都认为自己是“根桥”，根桥ID为自身的设备ID。通过交换BPDU消息，设备之间比较根桥ID，网络中根桥ID最小的设备被选为根桥。根桥上的所有端口都是转发状态。</li>
<li>选择根端口：非根桥设备将接收最优配置消息的那个端口定为根端口，根端口也是处于转发状态。</li>
<li>选择指定端口：设备根据根端口的配置消息和根端口的路径开销，为每个端口计算一个指定端口配置消息，然后将计算出的配置消息与角色待定端口自己的配置消息进行比较。<ul>
<li>如果计算出的配置消息更优，则该端口被确定为指定端口，其配置消息也被计算出的配置消息替换，并周期性地向外发送；</li>
<li>如果该端口自己的配置消息更优，则不更新该端口的配置消息并将该端口阻塞。该端口将不再转发数据，且只接收不发送配置消息。</li>
</ul>
</li>
</ol>
<p>一旦根桥、根端口和指定端口选举成功，整个树形拓扑就建立完毕了。在拓扑稳定后，只有根端口和指定端口转发流量，其他的非根、非指定端口都处于阻塞（Blocking）状态，它们只接收STP协议报文而不转发用户流量。下面结合例子说明STP算法实现的具体过程。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://download.huawei.com/mdl/image/download?uuid=a968eab295024515a010588adcdd72ba" alt="STP算法实现过程组网图及计算后的拓扑"></p>
<p><em>STP算法实现过程组网图及计算后的拓扑</em></p>
<p>如<a target="_blank" rel="noopener" href="https://info.support.huawei.com/info-finder/encyclopedia/zh/STP.html#fig_dc_fd_stp_000702">图1-3</a>所示，DeviceA、DeviceB和DeviceC的优先级分别为0、1和2，DeviceA与DeviceB之间、DeviceA与DeviceC之间以及DeviceB与DeviceC之间链路的路径开销分别为5、10和4。</p>
<ol>
<li><p>各设备的初始状态</p>
<p>各设备的初始状态如<a target="_blank" rel="noopener" href="https://info.support.huawei.com/info-finder/encyclopedia/zh/STP.html#tab_dc_fd_stp_000703">表1-3</a>所示。</p>
<p><strong>表1-3</strong> 各设备的初始状态</p>
<table>
<thead>
<tr>
<th>设备</th>
<th>端口名称</th>
<th>端口的配置消息</th>
</tr>
</thead>
<tbody><tr>
<td>DeviceA</td>
<td>Port A1</td>
<td>{0，0，0，Port A1}</td>
</tr>
<tr>
<td>Port A2</td>
<td>{0，0，0，Port A2}</td>
<td></td>
</tr>
<tr>
<td>DeviceB</td>
<td>Port B1</td>
<td>{1，0，1，Port B1}</td>
</tr>
<tr>
<td>Port B2</td>
<td>{1，0，1，Port B2}</td>
<td></td>
</tr>
<tr>
<td>DeviceC</td>
<td>Port C1</td>
<td>{2，0，2，Port C1}</td>
</tr>
<tr>
<td>Port <a target="_blank" rel="noopener" href="https://info.support.huawei.com/info-finder/encyclopedia/zh/%E5%91%BD%E4%BB%A4%E4%B8%8E%E6%8E%A7%E5%88%B6.html">C2</a></td>
<td>{2，0，2，Port C2}</td>
<td></td>
</tr>
</tbody></table>
</li>
<li><p>各设备的比较过程及结果</p>
<p>各设备的比较过程及结果如<a target="_blank" rel="noopener" href="https://info.support.huawei.com/info-finder/encyclopedia/zh/STP.html#tab_dc_fd_stp_000704">表1-4</a>所示，表格内配置消息中各项的具体含义为：{根桥ID，累计根路径开销，发送者BID，发送端口PID}。</p>
<p><strong>表1-4</strong> STP拓扑计算过程及结果</p>
<table>
<thead>
<tr>
<th>设备</th>
<th>比较过程</th>
<th>比较后端口的配置消息</th>
</tr>
</thead>
<tbody><tr>
<td>DeviceA</td>
<td>Port A1收到Port B1的配置消息{1，0，1，Port B1}，发现自己的配置消息{0，0，0，Port A1}更优，于是将其丢弃。Port A2收到Port C1的配置消息{2，0，2，Port C1}，发现自己的配置消息{0，0，0，Port A2}更优，于是将其丢弃。DeviceA发现自己各端口的配置消息中的根桥和指定桥都是自己，于是认为自己就是根桥，各端口的配置消息都不作任何修改，此后便周期性地向外发送配置消息。</td>
<td>Port A1：{0，0，0，Port A1}Port A2：{0，0，0，Port A2}</td>
</tr>
<tr>
<td>DeviceB</td>
<td>Port B1收到Port A1的配置消息{0，0，0，Port A1}，发现其比自己的配置消息{1，0，1，Port B1}更优，于是更新自己的配置消息。Port B2收到Port C2的配置消息{2，0，2，Port C2}，发现自己的配置消息{1，0，1，Port B2}更优，于是将其丢弃。</td>
<td>Port B1：{0，0，0，Port A1}Port B2：{1，0，1，Port B2}</td>
</tr>
<tr>
<td>DeviceB比较自己各端口的配置消息，发现Port B1的配置消息最优，于是该端口被确定为根端口，其配置消息不变。DeviceB根据根端口的配置消息和路径开销，为Port B2计算出指定端口的配置消息{0，5，1，Port B2}，然后与Port B2本身的配置消息{1，0，1，Port B2}进行比较，发现计算出的配置消息更优，于是Port B2被确定为指定端口，其配置消息也被替换为计算出的配置消息，并周期性地向外发送。</td>
<td>根端口Port B1：{0，0，0，Port A1}指定端口Port B2：{0，5，1，Port B2}</td>
<td></td>
</tr>
<tr>
<td>DeviceC</td>
<td>Port C1收到Port A2的配置消息{0，0，0，Port A2}，发现其比自己的配置消息{2，0，2，Port C1}更优，于是更新自己的配置消息。Port C2收到Port B2更新前的配置消息{1，0，1，Port B2}，发现其比自己的配置消息{2，0，2，Port C2}更优，于是更新自己的配置消息。</td>
<td>Port C1：{0，0，0，Port A2}Port C2：{1，0，1，Port B2}</td>
</tr>
<tr>
<td>DeviceC比较自己各端口的配置消息，发现Port C1的配置消息最优，于是该端口被确定为根端口，其配置消息不变。DeviceC根据根端口的配置消息和路径开销，为Port C2计算出指定端口的配置消息{0，10，2，Port C2}，然后与Port C2本身的配置消息{1，0，1，Port B2}进行比较，发现计算出的配置消息更优，于是Port C2被确定为指定端口，其配置消息也被替换为计算出的配置消息。</td>
<td>根端口Port C1：{0，0，0，Port A2}指定端口Port C2：{0，10，2，Port C2}</td>
<td></td>
</tr>
<tr>
<td>Port C2收到Port B2更新后的配置消息{0，5，1，Port B2}，发现其比自己的配置消息{0，10，2，Port C2}更优，于是更新自己的配置消息。Port C1收到Port A2周期性发来的配置消息{0，0，0，Port A2}，发现其与自己的配置消息一样，于是将其丢弃。</td>
<td>Port C1：{0，0，0，Port A2}Port C2：{0，5，1，Port B2}</td>
<td></td>
</tr>
<tr>
<td>DeviceC比较Port C1的根路径开销10（收到的配置消息中的根路径开销0＋本端口所在链路的路径开销10）与Port C2的根路径开销9（收到的配置消息中的根路径开销5＋本端口所在链路的路径开销4），发现后者更小，因此Port C2的配置消息更优，于是Port C2被确定为根端口，其配置消息不变。DeviceC根据根端口的配置消息和路径开销，为Port C1计算出指定端口的配置消息{0，9，2，Port C1}，然后与Port C1本身的配置消息{0，0，0，Port A2}进行比较，发现本身的配置消息更优，于是Port C1被阻塞，其配置消息不变。从此，Port C1不再转发数据，直至有触发生成树计算的新情况出现，譬如DeviceB与DeviceC之间的链路down掉。</td>
<td>阻塞端口Port C1：{0，0，0，Port A2}根端口Port C2：{0，5，1，Port B2}</td>
<td></td>
</tr>
</tbody></table>
</li>
</ol>
<p>拓扑稳定后，根桥仍然按照Hello Timer规定的时间间隔发送配置BPDU报文，非根桥设备从根端口收到配置BPDU报文，通过指定端口转发。如果接收到的优先级比自己高的配置BPDU，则非根桥设备会根据收到的配置BPDU中携带的信息更新自己相应的端口存储的配置BPDU信息。</p>
<h3 id="STP的典型应用"><a href="#STP的典型应用" class="headerlink" title="STP的典型应用"></a>STP的典型应用</h3><p>在一个复杂的网络中，网络规划者由于冗余备份的需要，一般都倾向于在设备之间部署多条物理链路，其中一条作主用链路，其他链路作备份。这样就难免会形成环形网络，若网络中存在环路，可能会引起广播风暴和MAC表项被破坏。</p>
<p>如<a target="_blank" rel="noopener" href="https://info.support.huawei.com/info-finder/encyclopedia/zh/STP.html#fig_dc_fd_stp_001703">图1-4</a>所示，在网络中部署STP协议，通过彼此交互信息发现网络中的环路，并有选择的对某个端口进行阻塞，最终将环形网络结构修剪成无环路的树形网络结构，从而防止报文在环形网络中不断增生和无限循环，避免设备由于重复接收相同的报文造成处理能力下降。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://download.huawei.com/mdl/image/download?uuid=0450492f545f42208fd6b2997296830d" alt="STP典型应用组网图"><br><em>STP典型应用组网图</em></p>
<blockquote>
<p><strong>生成树解决的问题 —— 2层环路问题</strong></p>
<ul>
<li><p>广播风暴</p>
<blockquote>
<p>由于泛洪的数据帧，无休止的在设备之间传递，设备性能下降，直到死机。</p>
</blockquote>
</li>
<li><p>mac地址表震荡 &#x2F; 漂移</p>
<blockquote>
<p>MAC地址漂移指的是MAC地址表项的出接口发生了变更。造成数据无法正常转发，影响业务</p>
</blockquote>
</li>
</ul>
</blockquote>
<blockquote>
<p>BPDU：<strong>桥</strong>协议数据单元</p>
</blockquote>
<blockquote>
<p>STP协议：将某些端口置为“逻辑上的”阻塞状态，处于阻塞状态的端口，平时无法进行业务数据的发送和接收，当网络中环路消除时，端口可以自动切换转改为“转发状态”。</p>
</blockquote>
<blockquote>
<p>发送设备BID：发出配置BPDU的设备的BID </p>
<p>发送端口的PID：发出配置BPDU的端口的PID </p>
<p>根设备&#x3D;根交换机&#x3D;根桥</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230719170354192.png" alt="image-20230719170354192"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230719173152326.png" alt="image-20230719173152326"></p>
<blockquote>
<ol>
<li><p>选举root（根桥）</p>
<p>比较BID（BridgeID：桥ID，每台设备都有自己的桥ID，可以理解为设备的名字）&#x3D; 优先级 (16位，默认32768 ，可手动配置，4096的倍数) + MAC地址（交换机背板MAC48位）</p>
<p><strong>注：BID越小越优先</strong></p>
</li>
<li><p>选根端口（root port）（根端口是在除了根桥的交换机的其他交换机上选择根端口）</p>
<p>比较入方向的根路径开销（RPC）</p>
</li>
</ol>
</blockquote>
<p><strong><code>扩展：</code></strong></p>
<blockquote>
<p>交换机的三种转发行为：</p>
<ol>
<li>转发：对已知的单播目的MAC地址执行转发；</li>
<li>泛洪：对未知的单播目的MAC和广播组播MAC进行泛洪；</li>
<li>丢弃：对不能识别的数据帧产生丢弃行为</li>
</ol>
<p>二层交换机转发时，不会改变数据帧的源MAC地址，三层交换机转发时，源MAC地址才发生改变</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230719221114711.png"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230720171031450.png" alt="image-20230720171031450"></p>
<p>生成树协议在设备上默认都是开启的，</p>
<p><strong><code>为什么需要生成树协议？</code></strong></p>
<blockquote>
<p>在二层网络中，由于交换机的转发行为，导致二层网络的物理拓扑 上出现环路，那么报文的转发也会出现环路，而环路引来了广播风暴、MAC地址表震荡&#x2F;漂移、重复数据帧等问题（交换机性能的消耗），所以需要STP协议来为二层网络实现防环和破环的作用。</p>
<p>防环的作用：</p>
<p>提前在三台交换机上启用STP协议，为了防止LSW1与LSW3相连产生环路</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230719231407929.png" alt="image-20230719231407929"></p>
<p>破环的作用：</p>
<p>当网络中已经产生环路，开启STP协议实现破环的作用</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230719232042736.png" alt="image-20230719232042736"></p>
<p>华为生成树协议标准：</p>
<ol>
<li>STP（收敛速度在30~50秒之间，收敛速度比较慢）</li>
<li>RSTP (后来用户对网络，实时性要求越来越高，推出了RSTP，RSTP在STP的基础上做出了一些改变，用来提高收敛速度并且能够防止环路)</li>
<li>MSTP（在华为设备中，默认启用MSTP）</li>
</ol>
<p>思科生成树协议标准：</p>
<ol>
<li>PVST（等同于STP）</li>
<li>PVST</li>
</ol>
</blockquote>
<p>为什么叫根桥？</p>
<blockquote>
<p>是因为早期的STP协议用在网桥设备的组网中</p>
</blockquote>
<p><strong><code>STP Spanning-tree</code></strong></p>
<blockquote>
<ul>
<li>根桥：</li>
</ul>
<blockquote>
<p>为了防止网络中的环路，STP协议选择了一个参考点，这个参考点就是根桥。</p>
</blockquote>
<ul>
<li><p>桥ID：桥优先级（默认值为32768）+ 桥MAC地址（背板MAC）</p>
</li>
<li><p>非根桥：除了根桥以外所有的交换机都叫做非根桥。</p>
</li>
<li><p>ROOT ID：根ID。根桥的桥ID叫做根ID。</p>
</li>
<li><p>BPDU：桥协议数据单元。</p>
</li>
<li><p>PID：端口ID。端口优先级（默认值是128）+ 端口号（交换机上启用了STP协议，交换机上的接口也启用了STP协议，那么交换机会随机分配一个端口号）</p>
</li>
<li><p>RPC：（Root Path Cost）根路径开销，非根桥去往根桥最短的Cost。</p>
</li>
<li><p>RP：根端口。是非根桥去往根桥最近的接口。</p>
</li>
<li><p>DP：指定端口。在需要的时候用来转发数据。</p>
</li>
<li><p>AP：逻辑上的阻塞端口</p>
<blockquote>
<p>STP协议中Cost的取值标准：</p>
<ol>
<li><p>802.1D-1998（思科设备默认使用802.1D-1998）</p>
<blockquote>
<p>cost &#x3D; 参考带宽  &#x2F;  接口带宽     &#x2F;&#x2F; 只针对802.1D-1998取值标准</p>
</blockquote>
</li>
<li><p>802.1T标准方式（默认使用802.1T标准）</p>
</li>
<li><p>华为私有</p>
</li>
</ol>
<blockquote>
<p>华为修改方式：</p>
<pre><code>[huawei]stp pathcost-standard // 修改STP协议的Cost取值标准
</code></pre>
<p>思科修改方式：</p>
<pre><code>Switch(config)#spanning-tree pathcost method ?
 long // 修改为802.1T标准方式
 short // 修改为802.1D-1998
</code></pre>
</blockquote>
</blockquote>
</li>
</ul>
</blockquote>
<p>网络设备中没有小数概念，也没有四舍五入，有小数取值的数字只取整数位，小于1的数字取1。</p>
<p><strong><code>STP工作流程：(所有的比较原则，都是越小越优)</code></strong></p>
<ol>
<li><p>选择根桥：</p>
<blockquote>
<p>比较桥ID</p>
<ul>
<li>首先比较桥优先级</li>
<li>比较MAC地址</li>
</ul>
</blockquote>
</li>
<li><p>在每个非根桥上选择一个根端口。</p>
<p>非根桥上接受最好的BPDU的端口成为根端口，如何判断一个最好的BPDU呢？</p>
<blockquote>
<p>BPDU的核心参数：</p>
<ul>
<li>ROOT ID：用于标识当前根桥的桥ID。（同一根桥，Root ID是一致的）</li>
<li>RPC：用于描述根路径开销。根桥始发是0。</li>
<li>Sender BID：BPDU发送者的BID。</li>
<li>Sender PID：BPDU发送者的PID。</li>
</ul>
</blockquote>
</li>
<li><p>在每一条链路上选择一个指定端口。</p>
<p>当根端口确定之后，交换机会为自己的每个指定端口，计算出一个未来要发送的BPDU参数，和接受到的BPDU参数做对比，如果自己更优则保持DP不变，如果对方更优则将自己本接口阻塞。</p>
</li>
</ol>
<p><strong><code>STP端口角色：</code></strong></p>
<ul>
<li>RP：根端口。非根桥去往根桥最近的接口。</li>
<li>DP：指定端口。按需用来转发数据，或者是发送BPDU的端口。</li>
</ul>
<p><strong><code>STP端口状态：</code></strong></p>
<ul>
<li><p>disable：禁用状态。没有启用STP协议的端口或者人为关闭的端口处于禁用状态。</p>
</li>
<li><p>listending：侦听状态。可以发送BPDU，接受BDPU，不学习MAC地址，不转发数据</p>
</li>
<li><p>learning：学习状态。可以发送BPDU，接受BDPU，学习MAC地址，不转发数据</p>
</li>
<li><p>forwarding：转发状态。可以发送BPDU，接受BDPU，学习MAC地址，转发数据</p>
</li>
<li><p>Blocking：阻塞状态。不可以发送BDPU，可以接受BPDU，不学习MAC地址，不转发数据。</p>
</li>
</ul>
<p>Forward Delay：转发延迟时间（15s）</p>
<p>为什么会有侦听状态的15s时间？</p>
<blockquote>
<p>用于STP收敛，防止临时环路的产生。</p>
</blockquote>
<p>为什么需要学习状态的15s时间？</p>
<blockquote>
<p>用于交换机学习MAC地址，形成MAC地址表，防止大量未知单播帧的泛洪对二层网络造成冲击。</p>
</blockquote>
<p>查看设备背板MAC地址：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Huawei&gt;display bridge mac-address // 查看设备背板MAC地址</span><br></pre></td></tr></table></figure>

<p>现在华为交换机设备默认启用MSTP协议，而不是STP协议</p>
<p>更改为STP模式的命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Huawei]STP mode stp</span><br></pre></td></tr></table></figure>

<p>查看当前生成树的接口信息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Huawei&gt;display stp brief</span><br></pre></td></tr></table></figure>

<p>查看生成树信息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Huawei&gt;display stp</span><br></pre></td></tr></table></figure>

<p>华为里查看所有配置信息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">display cu</span><br></pre></td></tr></table></figure>



<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230720164637237.png" alt="image-20230720164637237"></p>
<p><strong><code>根桥选举出来之后，只有根桥产生BPDU，发送给非根桥</code></strong></p>
<p><strong><code>交换机刚开始启动之后，所有的交换机都会认为自己是根桥，所有的接口角色都是DP角色</code></strong></p>
</blockquote>
<blockquote>
<p>4个计时器：</p>
<ul>
<li><p>Hello Time：BPDU的发送时间间隔。（2s）</p>
</li>
<li><p>Forward Delay：转发延迟时间。</p>
</li>
<li><p>Max Age：BPDU的最大年龄。（20s）</p>
</li>
<li><p>Message Age：BPDU的当前年龄。</p>
<blockquote>
<p>实际上，设备实现的时候，是每经过一次转发将Message Age+1。</p>
<p>当一台交换机收到BPDU之后，会将Message和Max作对比，如果message大于了max值，交换机将会忽略此BPDU的处理。</p>
</blockquote>
</li>
</ul>
<p><strong><code>STP针对拓扑变化的收敛：</code></strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230724012648981.png" alt="image-20230724012648981"></p>
</blockquote>
<blockquote>
<p>STP &#x3D; 802.1D</p>
<p>RSTP &#x3D; 802.1W</p>
<p>MASTP &#x3D; 802.1S</p>
</blockquote>
<h2 id="17、RSTP"><a href="#17、RSTP" class="headerlink" title="17、RSTP"></a>17、RSTP</h2><blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230723222511107.png" alt="image-20230723222511107"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230723222633723.png" alt="image-20230723222633723"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230723222817744.png" alt="image-20230723222817744"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230723222905126.png" alt="image-20230723222905126"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230723223030949.png" alt="image-20230723223030949"></p>
<p>为什么使用RSTP？</p>
<blockquote>
<p>随着网络的发展，用户对于网络质量的实时性要求越来越高，传统的STP由于收敛时间大约在30s-50s之间，无法满足用户对网络的需求，所以推出了802.1W（RSTP）协议。</p>
</blockquote>
<p>RSTP如何改善收敛缓慢的问题呢？</p>
<blockquote>
<p>在RSTP中提出了几个快速收敛机制，用于提高STP收敛速度。</p>
<ol>
<li><p>P&#x2F;A机制</p>
<blockquote>
<p>作用：让一条链路快速进入到转发状态。节省了30s</p>
<p>P&#x2F;A机制的前提条件：只能在点对点的全双工链路上运行。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230723124013674.png" alt="image-20230723124013674"></p>
</blockquote>
<ol start="2">
<li>根端口快速切换机制（Uplinkfast）节省了30s</li>
</ol>
<blockquote>
<p>当RP故障之后，交换机从多个AP中重新选取出新的RP，直接过渡到转发状态。</p>
</blockquote>
</li>
<li><p>次级BPDU立即处理（节省了20s），结合P&#x2F;A机制（节省了30s）</p>
</li>
<li><p>边缘端口：EP（Edge port）（思科叫做portfast）</p>
<blockquote>
<p>当把交换机的一个接口设置为EP的时候，交换机一旦开机，STP进程在接口上运行，此时发现接口为EP，则会直接进入到转发状态，而无需等待30s时间。</p>
</blockquote>
</li>
</ol>
<blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230723182122957.png" alt="image-20230723182122957"></p>
</blockquote>
<blockquote>
<p>可能有问题，等会重新整理</p>
<p><strong>20s：指定端口转为根端口需要20s</strong></p>
<p><strong>30s：discarding到达学习状态需要15s，学习状态到转发状态需要15s</strong></p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<p>相比于STP，RSTP的一个突出优势就在于快速收敛能力，而RSTP实现快速收敛关键在于引入了<a target="_blank" rel="noopener" href="https://support.huawei.com/enterprise/zh/doc/EDOC1100247752/5cd7d504#section716102733411">Proposal&#x2F;Agreement机制</a>、<a target="_blank" rel="noopener" href="https://support.huawei.com/enterprise/zh/doc/EDOC1100247752/5cd7d504#section12941419183618">根端口快速切换机制</a>、<a target="_blank" rel="noopener" href="https://support.huawei.com/enterprise/zh/doc/EDOC1100247752/5cd7d504#section10931739115211">边缘端口</a>。</p>
<h2 id="Proposal-x2F-Agreement机制"><a href="#Proposal-x2F-Agreement机制" class="headerlink" title="Proposal&#x2F;Agreement机制"></a>Proposal&#x2F;Agreement机制</h2><p>Proposal&#x2F;Agreement机制简称P&#x2F;A机制，其目的是使一个指定端口尽快进入Forwarding状态。如<a target="_blank" rel="noopener" href="https://support.huawei.com/enterprise/zh/doc/EDOC1100247752/5cd7d504#fig_dc_fd_stp_000901">图13-11</a>所示，根桥S1和S2之间新添加了一条链路。在当前状态下，S2的另外几个端口p2是Alternate端口，p3是指定端口且处于Forwarding状态，p4是边缘端口。</p>
<p><strong>图13-11</strong> Proposal&#x2F;Agreement过程示意图<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://download.huawei.com/mdl/image/download?uuid=afd2dc7d994d4d8bbbd44170313b82bd" alt="img"></p>
<p>新链路连接成功后，P&#x2F;A机制协商过程如下：</p>
<ol>
<li>p0和p1两个端口马上都先成为指定端口，发送RST BPDU。</li>
<li>S2的p1口收到更优的RST BPDU，马上意识到自己将成为根端口，而不是指定端口，停止发送RST BPDU。</li>
<li>S1的p0进入Discarding状态，于是发送的RST BPDU中把Proposal和Agreement置1。</li>
<li>S2收到根桥发送来的携带Proposal的RST BPDU，开始将自己的所有端口进入sync变量置位（即同步变量：临时阻塞除边缘端口外的其他端口）。</li>
<li>p2已经阻塞，状态不变；p4是边缘端口，不参与运算；所以只需要阻塞非边缘指定端口p3。</li>
<li>各端口的sync变量置位后，p2、p3进入Discarding状态，p1进入Forwarding状态并向S1返回Agreement位置位的回应RST BPDU。</li>
<li>当S1判断出这是对刚刚发出的Proposal的回应，于是端口p0马上进入Forwarding状态。</li>
</ol>
<p>下游设备继续执行P&#x2F;A协商过程。</p>
<p>事实上对于STP，指定端口的选择可以很快完成，主要的速度瓶颈在于：为了避免环路，必须等待足够长的时间，使全网的端口状态全部确定，也就是说必须要等待至少一个Forward Delay所有端口才能进行转发。而RSTP的主要目的就是消除这个瓶颈，通过阻塞自己的非根端口来保证不会出现环路。而使用P&#x2F;A机制加快了上游端口转到Forwarding状态的速度。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://download.huawei.com/mdl/image/download?uuid=033869c9ec754508aa670a718515e8a1" alt="img"></p>
<p>P&#x2F;A机制要求两台交换设备之间链路必须是点对点的全双工模式。一旦P&#x2F;A协商不成功，指定端口的选择就需要等待两个Forward Delay，协商过程与STP一样。</p>
</blockquote>
<blockquote>
<h2 id="根端口快速切换机制"><a href="#根端口快速切换机制" class="headerlink" title="根端口快速切换机制"></a>根端口快速切换机制</h2><p>如果RSTP网络中一个根端口失效，那么网络中最优的Alternate端口将成为根端口并直接进入Forwarding状态。因为通过这个Alternate端口连接的网段上必然有个指定端口可以通往根桥。</p>
<p>如<a target="_blank" rel="noopener" href="https://support.huawei.com/enterprise/zh/doc/EDOC1100247752/5cd7d504#fig_dc_fd_stp_000805">图13-12</a>所示，S1为根桥，S2为备份根桥，S3的GE0&#x2F;0&#x2F;2为Alternate端口。S3的根端口GE0&#x2F;0&#x2F;1接口故障：</p>
<ul>
<li>STP模式时，S3的GE0&#x2F;0&#x2F;2会先切换成根端口并进入Listening状态，等待一个Forward Delay时间（缺省值为15秒）后进入Learning状态，继续等待一个Forward Delay时间（缺省值为15秒）后才进入Forwarding状态。</li>
<li>RSTP模式时，S3的GE0&#x2F;0&#x2F;2会切换成根端口，并直接进入Forwarding状态。</li>
</ul>
<p>相比较STP模式时接口需要等待2*Forward Delay时间才能进入Forwarding状态，RSTP模式时的根端口快速切换机制使接口直接切换成Forwarding状态，减少业务流量丢包。</p>
<p><strong>图13-12</strong> 根端口快速切换机制<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://download.huawei.com/mdl/image/download?uuid=f2c71baad5e1423dace1fe13f431d796" alt="img"></p>
</blockquote>
<blockquote>
<h2 id="边缘端口的引入"><a href="#边缘端口的引入" class="headerlink" title="边缘端口的引入"></a>边缘端口的引入</h2><p>在RSTP里面，如果某一个指定端口位于整个网络的边缘，即不再与其他交换设备连接，而是直接与终端设备直连，这种端口叫做边缘端口。</p>
<p>边缘端口不参与RSTP运算，可以由Disable直接转到Forwarding状态，且不经历时延，就像在端口上将STP禁用。但是一旦边缘端口收到配置BPDU，就丧失了边缘端口属性，成为普通STP端口，并重新进行生成树计算，从而引起网络震荡。</p>
</blockquote>
<blockquote>
<h1 id="RSTP的保护功能"><a href="#RSTP的保护功能" class="headerlink" title="RSTP的保护功能"></a>RSTP的保护功能</h1><p>为了保持网络运行的稳定，RSTP提供了以下几种保护功能：</p>
<ul>
<li><p>BPDU保护</p>
<p>在RSTP网络中，正常情况下，边缘端口不会收到RST BPDU，启用了BPDU保护功能后，如果有人伪造RST BPDU恶意攻击交换机，边缘端口将被Error-Down。</p>
<p>如<a target="_blank" rel="noopener" href="https://support.huawei.com/enterprise/zh/doc/EDOC1100247752/c5de84be#fig_dc_fd_stp_000804">图13-13</a>所示，S3上将与PC相连的端口设置为边缘端口，当边缘端口接收到RST BPDU时，交换机会自动将边缘端口设置为非边缘端口，并重新进行生成树计算。当攻击者发送的RST BPDU报文中的桥优先级高于现有网络中根桥优先级时会改变当前网络拓扑，可能会导致业务流量中断。这是网络中一种简单的拒绝服务DoS（Denial of Service）攻击方式。</p>
<p><strong>图13-13</strong> BPDU保护<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://download.huawei.com/mdl/image/download?uuid=771d848432824ae097fe1db5e0bbf958" alt="img"></p>
<p>交换机上启动了BPDU保护功能后，如果边缘端口收到RST BPDU，边缘端口将被error-down，但是边缘端口属性不变，同时通知网管系统。交换机上会打印如下日志信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MSTP/4/BPDU_PROTECTION:This edged-port [port-name] that enabled BPDU-Protection will be shutdown, because it received BPDU packet!</span><br></pre></td></tr></table></figure>
</li>
<li><p>根保护</p>
<p>由于维护人员的错误配置或网络中的恶意攻击，网络中合法根桥有可能会收到优先级更高的RST BPDU，使得合法根桥失去根地位，从而引起网络拓扑结构的错误变动。这种不合法的拓扑变化，会导致原来应该通过高速链路的流量被牵引到低速链路上，造成网络拥塞。</p>
<p>如<a target="_blank" rel="noopener" href="https://support.huawei.com/enterprise/zh/doc/EDOC1100247752/c5de84be#fig_dc_fd_stp_000807">图13-14</a>所示，DeviceA和DeviceB处于网络核心层，两者间的链路带宽为1000M，DeviceA为网络中的根桥。DeviceC处于接入层，DeviceC和DeviceA、DeviceC和DeviceB之间的链路带宽为100M。正常情况下，DeviceB和DeviceC之间的链路被阻塞。</p>
<p>当DeviceD新接入DeviceC时，由于DeviceD的桥优先级高于DeviceA，此时DeviceD会被选举为新的根桥，如果两个核心交换机DeviceA和DeviceB之间的千兆链路被阻塞，会导致VLAN中的流量都通过两条100M链路传输，可能会引起网络拥塞及流量丢失。</p>
<p><strong>图13-14</strong> 根保护<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://download.huawei.com/mdl/image/download?uuid=9a9f029d58784d1cb7bef306a7905151" alt="img"></p>
<p>此时可以在DeviceC连接DeviceD的端口上，配置根保护。对于启用Root保护功能的指定端口，其端口角色只能保持为指定端口。一旦启用Root保护功能的指定端口收到优先级更高的RST BPDU时，端口状态将进入Discarding状态，不再转发报文。在经过一段时间（通常为两倍的Forward Delay），如果端口一直没有再收到优先级较高的RST BPDU，端口会自动恢复到正常的Forwarding状态。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://download.huawei.com/mdl/image/download?uuid=529597a4962d408e84cce59826ca02d0" alt="img"></p>
<p>Root保护功能只能在指定端口上配置生效。</p>
</li>
<li><p>环路保护</p>
<p>在运行RSTP协议的网络中，根端口和其他阻塞端口状态是依靠不断接收来自上游交换设备的RST BPDU维持。当由于链路拥塞或者单向链路故障导致这些端口收不到来自上游交换设备的RST BPDU时，此时交换设备会重新选择根端口。原先的根端口会转变为指定端口，而原先的阻塞端口会迁移到转发状态，从而造成交换网络中可能产生环路。</p>
<p>如<a target="_blank" rel="noopener" href="https://support.huawei.com/enterprise/zh/doc/EDOC1100247752/c5de84be#fig_dc_fd_stp_000803">图13-15</a>所示，当BP2-CP1之间的链路发生拥塞时，DeviceC由于根端口CP1在超时时间内收不到来自上游设备的BPDU报文，Alternate端口CP2放开转变成了根端口，根端口CP1转变成指定端口，从而形成了环路。</p>
<p><strong>图13-15</strong> 链路发生拥塞情况拓扑的变化<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://download.huawei.com/mdl/image/download?uuid=3886f43d804240628e29e8bf915e41ec" alt="img"></p>
<p>在启动了环路保护功能后，如果根端口或Alternate端口长时间收不到来自上游设备的BPDU报文时，则向网管发出通知信息（此时根端口会进入Discarding状态，角色切换为指定端口），而Alternate端口则会一直保持在阻塞状态（角色也会切换为指定端口），不转发报文，从而不会在网络中形成环路。直到链路不再拥塞或单向链路故障恢复，端口重新收到BPDU报文进行协商，并恢复到链路拥塞或者单向链路故障前的角色和状态。</p>
<p>交换机上会打印如下日志信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MSTP/4/LOOP_GUARD:MSTP process [process-id] Instance[instance-id]&#x27;s LOOP-Protection port [port-name] did not receive message in prescriptive time!</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://download.huawei.com/mdl/image/download?uuid=529597a4962d408e84cce59826ca02d0" alt="img"></p>
<p>环路保护功能只能在根端口或Alternate端口上配置生效。</p>
</li>
<li><p>防TC-BPDU攻击</p>
<p>交换设备在接收到TC BPDU报文后，会执行MAC地址表项和ARP表项的删除操作。如果有人伪造TC BPDU报文恶意攻击交换设备时，交换设备短时间内会收到很多TC BPDU报文，频繁的删除操作会给设备造成很大的负担，给网络的稳定带来很大隐患。</p>
<p>启用防TC-BPDU报文攻击功能后，在单位时间内，交换设备处理TC BPDU报文的次数可配置。如果在单位时间内，交换设备在收到TC BPDU报文数量大于配置的阈值，那么设备只会处理阈值指定的次数。对于其他超出阈值的TC BPDU报文，定时器到期后设备只对其统一处理一次。这样可以避免频繁的删除MAC地址表项和ARP表项，从而达到保护设备的目的。</p>
</li>
</ul>
</blockquote>
<blockquote>
<h2 id="BPDU报文分类"><a href="#BPDU报文分类" class="headerlink" title="BPDU报文分类"></a>BPDU报文分类</h2><p>BPDU报文可以分为以下几类。</p>
<ul>
<li>配置BPDU（Configuration BPDU）：STP用来进行生成树计算和维护生成树拓扑的报文。</li>
<li>RST BPDU：RSTP用来进行生成树计算和维护生成树拓扑的报文。</li>
<li>MST BPDU：MSTP用来进行生成树计算和维护生成树拓扑的报文。</li>
<li>TCN BPDU（Topology Change Notification BPDU）：网络拓扑发生变化时用来通知相关设备的报文</li>
</ul>
</blockquote>
<blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230815195058772.png" alt="image-20230815195058772"></p>
</blockquote>
<blockquote>
<p>STP与RSTP端口状态比较</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230721153926804.png" alt="image-20230721153926804"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230721162023263.png" alt="image-20230721162023263"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230721162349899.png" alt="image-20230721162349899"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230721162124949.png" alt="image-20230721162124949"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230721162054904.png" alt="image-20230721162054904"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230721163015924.png" alt="image-20230721163015924"></p>
</blockquote>
<blockquote>
<p>STP与RSTP的区别：</p>
<ul>
<li>RSTP充分利用了BPDU里的flag字段（8个比特），STP只用到了最高位和最低位（TCA和TC）</li>
</ul>
</blockquote>
<blockquote>
<p>什么是SYNC？</p>
<blockquote>
<p>SYNC也叫作同步变量置位，是RSTP在P&#x2F;A协商的时候执行的一种动作，主要是为了防止临时环路产生的。</p>
<p>动作：阻塞所有的非边缘指定端口。</p>
</blockquote>
</blockquote>
<blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230723225028715.png" alt="image-20230723225028715"></p>
</blockquote>
<blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230724192623174.png" alt="image-20230724192623174"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230724192636278.png" alt="image-20230724192636278"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230724192654851.png" alt="image-20230724192654851"></p>
<p>​		<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230724192715254.png" alt="image-20230724192715254"></p>
</blockquote>
<h2 id="18、MSTP"><a href="#18、MSTP" class="headerlink" title="18、MSTP"></a>18、MSTP</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230724184927653.png" alt="image-20230724184927653"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230724184634610.png" alt="image-20230724184634610"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230724190556254.png" alt="image-20230724190556254"></p>
<blockquote>
<p>通过批量选择的快捷方式配置端口模式</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230724192445917.png" alt="image-20230724192445917"></p>
<h3 id="MSTP的网络层次"><a href="#MSTP的网络层次" class="headerlink" title="MSTP的网络层次"></a>MSTP的网络层次</h3><p>如<a target="_blank" rel="noopener" href="https://support.huawei.com/enterprise/zh/doc/EDOC1100247752/f7e8e63c#fig_dc_fd_stp_001201">图14-3</a>所示，MSTP网络中包含1个或多个MST域（MST Region），每个MST Region中包含一个或多个MSTI。组成MSTI的是运行STP&#x2F;RSTP&#x2F;MSTP的交换设备，MSTI是所有运行STP&#x2F;RSTP&#x2F;MSTP的交换设备经MSTP协议计算后形成的树状网络。</p>
<p><strong>图14-3</strong> MSTP网络层次示意图<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://download.huawei.com/mdl/image/download?uuid=6ef94fd6a03640598a5c411581fca357" alt="img"></p>
<h3 id="MST域（MST-Region）"><a href="#MST域（MST-Region）" class="headerlink" title="MST域（MST Region）"></a>MST域（MST Region）</h3><p>MST域是多生成树域（Multiple Spanning Tree Region），由交换网络中的多台交换设备以及它们之间的网段所构成。同一个MST域的设备具有下列特点：</p>
<ul>
<li>都启动了MSTP。</li>
<li>具有相同的域名。</li>
<li>具有相同的VLAN到生成树实例映射配置。</li>
<li>具有相同的MSTP修订级别配置。</li>
</ul>
<p>一个局域网可以存在多个MST域，各MST域之间在物理上直接或间接相连。用户可以通过MSTP配置命令把多台交换设备划分在同一个MST域内。</p>
<p>如<a target="_blank" rel="noopener" href="https://support.huawei.com/enterprise/zh/doc/EDOC1100247752/f7e8e63c#fig_dc_fd_stp_001202">图14-4</a>所示的MST Region 4中由交换设备A、B、C和D构成，域中有3个MSTI。</p>
<p><strong>图14-4</strong> MST Region示意图<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://download.huawei.com/mdl/image/download?uuid=d0b9294b58a74bcb8ba7f5f087e666cd" alt="img"></p>
<h3 id="VLAN映射表"><a href="#VLAN映射表" class="headerlink" title="VLAN映射表"></a>VLAN映射表</h3><p>VLAN映射表是MST域的属性，它描述了VLAN和MSTI之间的映射关系。</p>
<p>如<a target="_blank" rel="noopener" href="https://support.huawei.com/enterprise/zh/doc/EDOC1100247752/f7e8e63c#fig_dc_fd_stp_001202">图14-4</a>所示，MST Region 4的VLAN映射表是：</p>
<ul>
<li>VLAN1映射到MSTI1</li>
<li>VLAN2映射到MSTI2</li>
<li>其余VLAN映射到MSTI3</li>
</ul>
<h3 id="CST"><a href="#CST" class="headerlink" title="CST"></a>CST</h3><p>公共生成树CST（Common Spanning Tree）是连接交换网络内所有MST域的一棵生成树。</p>
<p>如果把每个MST域看作是一个节点，CST就是这些节点通过STP或RSTP协议计算生成的一棵生成树。</p>
<p>如<a target="_blank" rel="noopener" href="https://support.huawei.com/enterprise/zh/doc/EDOC1100247752/f7e8e63c#fig_dc_fd_stp_001201">图14-3</a>所示，黑色线条连接各个域构成CST。</p>
<h3 id="IST"><a href="#IST" class="headerlink" title="IST"></a>IST</h3><p>内部生成树IST（Internal Spanning Tree）是各MST域内的一棵生成树。</p>
<p>IST是一个特殊的MSTI，MSTI的ID为0，通常称为MSTI0。</p>
<p>IST是CIST在MST域中的一个片段。</p>
<p>如<a target="_blank" rel="noopener" href="https://support.huawei.com/enterprise/zh/doc/EDOC1100247752/f7e8e63c#fig_dc_fd_stp_001201">图14-3</a>所示，深蓝色线条在域中连接该域的所有交换设备构成IST。</p>
<h3 id="SST"><a href="#SST" class="headerlink" title="SST"></a>SST</h3><p>构成单生成树SST（Single Spanning Tree）有两种情况：</p>
<ul>
<li>运行STP或RSTP的交换设备只能属于一个生成树。</li>
<li>MST域中只有一个交换设备，这个交换设备构成单生成树。</li>
</ul>
<h3 id="CIST"><a href="#CIST" class="headerlink" title="CIST"></a>CIST</h3><p>公共和内部生成树CIST（Common and Internal Spanning Tree）是通过STP或RSTP协议计算生成的，连接一个交换网络内所有交换设备的单生成树。</p>
<p>如<a target="_blank" rel="noopener" href="https://support.huawei.com/enterprise/zh/doc/EDOC1100247752/f7e8e63c#fig_dc_fd_stp_001201">图14-3</a>所示，所有MST域的IST加上CST就构成一棵完整的生成树，即CIST。</p>
<h3 id="域根"><a href="#域根" class="headerlink" title="域根"></a>域根</h3><p>域根（Regional Root）分为IST域根和MSTI域根。</p>
<p>IST域根如<a target="_blank" rel="noopener" href="https://support.huawei.com/enterprise/zh/doc/EDOC1100247752/f7e8e63c#fig_dc_fd_stp_001201">图14-3</a>所示，在MST域中IST生成树中距离总根（CIST Root）最近的交换设备是IST域根。</p>
<p>一个MST域内可以生成多棵生成树，每棵生成树都称为一个MSTI。MSTI域根是每个多生成树实例的树根。如<a target="_blank" rel="noopener" href="https://support.huawei.com/enterprise/zh/doc/EDOC1100247752/f7e8e63c#fig_dc_fd_stp_001202">图14-4</a>所示，域中不同的MSTI有各自的域根。</p>
<h3 id="总根"><a href="#总根" class="headerlink" title="总根"></a>总根</h3><p>总根是CIST（Common and Internal Spanning Tree）的根桥。如<a target="_blank" rel="noopener" href="https://support.huawei.com/enterprise/zh/doc/EDOC1100247752/f7e8e63c#fig_dc_fd_stp_001201">图14-3</a>中的S1。</p>
<h3 id="主桥"><a href="#主桥" class="headerlink" title="主桥"></a>主桥</h3><p>主桥（Master Bridge）也就是IST Master，它是域内距离总根最近的交换设备。如<a target="_blank" rel="noopener" href="https://support.huawei.com/enterprise/zh/doc/EDOC1100247752/f7e8e63c#fig_dc_fd_stp_001201">图14-3</a>中的黄色交换机。</p>
<p>如果总根在MST域中，则总根为该域的主桥。</p>
<h3 id="端口角色"><a href="#端口角色" class="headerlink" title="端口角色"></a>端口角色</h3><p>根端口、指定端口、Alternate端口、Backup端口和边缘端口的作用同RSTP协议中定义，MSTP中定义的所有端口角色如<a target="_blank" rel="noopener" href="https://support.huawei.com/enterprise/zh/doc/EDOC1100247752/f7e8e63c#tab_dc_fd_stp_001201">表14-1</a>所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://download.huawei.com/mdl/image/download?uuid=f9d4e997715b40b2ab41bc2439768b79" alt="img"></p>
<p>除边缘端口外，其他端口角色都参与MSTP的计算过程。</p>
<p>同一端口在不同的生成树实例中可以担任不同的角色。</p>
<p><strong>表14-1</strong> 端口角色</p>
<table>
<thead>
<tr>
<th>端口角色</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>根端口</td>
<td>在非根桥上，离根桥最近的端口是本交换设备的根端口。根交换设备没有根端口。根端口负责向树根方向转发数据。如<a target="_blank" rel="noopener" href="https://support.huawei.com/enterprise/zh/doc/EDOC1100247752/f7e8e63c#fig_dc_fd_stp_001205">图14-5</a>所示，S1为根桥，CP1为S3的根端口，BP1为S2的根端口。</td>
</tr>
<tr>
<td>指定端口</td>
<td>对一台交换设备而言，它的指定端口是向下游交换设备转发BPDU报文的端口。如<a target="_blank" rel="noopener" href="https://support.huawei.com/enterprise/zh/doc/EDOC1100247752/f7e8e63c#fig_dc_fd_stp_001205">图14-5</a>所示，AP2和AP3为S1的指定端口，CP2为S3的指定端口。</td>
</tr>
<tr>
<td>Alternate端口</td>
<td>从配置BPDU报文发送角度来看，Alternate端口就是由于学习到其它网桥发送的配置BPDU报文而阻塞的端口。从用户流量角度来看，Alternate端口提供了从指定桥到根的另一条可切换路径，作为根端口的备份端口。如<a target="_blank" rel="noopener" href="https://support.huawei.com/enterprise/zh/doc/EDOC1100247752/f7e8e63c#fig_dc_fd_stp_001205">图14-5</a>所示，BP2为Alternate端口。</td>
</tr>
<tr>
<td>Backup端口</td>
<td>从配置BPDU报文发送角度来看，Backup端口就是由于学习到自己发送的配置BPDU报文而阻塞的端口。从用户流量角度来看，Backup端口作为指定端口的备份，提供了另外一条从根节点到叶节点的备份通路。如<a target="_blank" rel="noopener" href="https://support.huawei.com/enterprise/zh/doc/EDOC1100247752/f7e8e63c#fig_dc_fd_stp_001205">图14-5</a>所示，CP3为Backup端口。</td>
</tr>
<tr>
<td>Master端口</td>
<td>Master端口是MST域和总根相连的所有路径中最短路径上的端口，它是交换设备上连接MST域到总根的端口。Master端口是域中的报文去往总根的必经之路。Master端口是特殊域边缘端口，Master端口在CIST上的角色是Root Port，在其它各实例上的角色都是Master端口。如<a target="_blank" rel="noopener" href="https://support.huawei.com/enterprise/zh/doc/EDOC1100247752/f7e8e63c#fig_dc_fd_stp_001206">图14-6</a>所示，交换设备S1、S2、S3、S4和它们之间的链路构成一个MST域，S1交换设备的端口AP1在域内的所有端口中到总根的路径开销最小，所以AP1为Master端口。</td>
</tr>
<tr>
<td>域边缘端口</td>
<td>域边缘端口是指位于MST域的边缘并连接其它MST域或SST的端口。如<a target="_blank" rel="noopener" href="https://support.huawei.com/enterprise/zh/doc/EDOC1100247752/f7e8e63c#fig_dc_fd_stp_001206">图14-6</a>所示，MST域内的AP1、DP1和DP2都和其它域直接相连，它们都是本MST域的域边缘端口。</td>
</tr>
<tr>
<td>边缘端口</td>
<td>如果指定端口位于整个域的边缘，不再与任何交换设备连接，这种端口叫做边缘端口。边缘端口一般与用户终端设备直接连接。端口使能MSTP功能后，会默认启用边缘端口自动探测功能，当端口在（2 × Hello Timer + 1）秒的时间内收不到BPDU报文，自动将端口设置为边缘端口，否则设置为非边缘端口。</td>
</tr>
</tbody></table>
<p><strong>图14-5</strong> 根端口、指定端口、Alternate端口和Backup端口示意图<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://download.huawei.com/mdl/image/download?uuid=7dba91e39b8540b5ad588c0c446d940a" alt="img"></p>
<p><strong>图14-6</strong> Master端口和域边缘端口示意图<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://download.huawei.com/mdl/image/download?uuid=c5e6b76c110d462b92185cb9a69932dd" alt="img"></p>
<h3 id="MSTP的端口状态"><a href="#MSTP的端口状态" class="headerlink" title="MSTP的端口状态"></a>MSTP的端口状态</h3><p>MSTP定义的端口状态与RSTP协议中定义相同，如<a target="_blank" rel="noopener" href="https://support.huawei.com/enterprise/zh/doc/EDOC1100247752/f7e8e63c#tab_dc_fd_stp_001202">表14-2</a>所示。</p>
<p><strong>表14-2</strong> 端口状态</p>
<table>
<thead>
<tr>
<th>端口状态</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Forwarding</td>
<td>在这种状态下，端口既转发用户流量又处理BPDU报文。</td>
</tr>
<tr>
<td>Learning</td>
<td>这是一种过渡状态。在Learning下，交换设备会根据收到的用户流量，构建MAC地址表，但不转发用户流量，所以叫做学习状态。Learning状态的端口处理BPDU报文，不转发用户流量。</td>
</tr>
<tr>
<td>Discarding</td>
<td>Discarding状态的端口只处理BPDU报文。</td>
</tr>
</tbody></table>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://download.huawei.com/mdl/image/download?uuid=f9d4e997715b40b2ab41bc2439768b79" alt="img"></p>
<p>根端口、Master端口、指定端口和域边缘端口支持Forwarding、Learning和Discarding状态，Alternate端口和Backup端口仅支持Discarding状态。</p>
<h2 id="19、VRRP"><a href="#19、VRRP" class="headerlink" title="19、VRRP"></a>19、VRRP</h2><h3 id="为什么需要VRRP"><a href="#为什么需要VRRP" class="headerlink" title="为什么需要VRRP"></a>为什么需要VRRP</h3><p>随着网络的快速普及和相关应用的日益深入，各种增值业务（如IPTV、视频会议等）已经开始广泛部署，基础网络的可靠性日益成为用户关注的焦点，能够保证网络传输不中断对于终端用户非常重要。</p>
<p>现网中的**<code>主机使用缺省网关与外部网络联系时，如果Gateway出现故障，与其相连的主机将与外界失去联系，导致业务中断。</code>**</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://download.huawei.com/mdl/image/download?uuid=cc1883def8ec4302930bebff63dd0297" alt="局域网缺省网关示意图"><br><em>局域网缺省网关示意图</em></p>
<p>VRRP的出现很好地解决了这个问题。**<code>VRRP将多台设备组成一个虚拟设备，通过配置虚拟设备的IP地址为缺省网关，实现缺省网关的备份。</code>**当网关设备发生故障时，VRRP机制能够选举新的网关设备承担数据流量，从而保障网络的可靠通信。如下图所示，当Master设备故障时，发往缺省网关的流量将由Backup设备进行转发。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://download.huawei.com/mdl/image/download?uuid=85aa625a4ab449818b17a3575cd4e320" alt="VRRP备份组示意图"><br><em>VRRP备份组示意图</em></p>
<h3 id="VRRP的三种状态"><a href="#VRRP的三种状态" class="headerlink" title="VRRP的三种状态"></a>VRRP的三种状态</h3><p>**<code>VRRP协议中定义了三种状态机：初始状态（Initialize）、活动状态（Master）、备份状态（Backup）</code>**。其中，只有处于Master状态的设备才可以转发那些发送到虚拟IP地址的报文。下表详细描述了三种状态。</p>
<p><strong>表1-1</strong> VRRP协议状态</p>
<table>
<thead>
<tr>
<th>状态</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Initialize</td>
<td>该状态为VRRP不可用状态，在此状态时设备不会对VRRP通告报文做任何处理。通常设备启动时或设备检测到故障时会进入Initialize状态。</td>
</tr>
<tr>
<td>Master</td>
<td>当VRRP设备处于Master状态时，它将会承担虚拟路由设备的所有转发工作，并定期向整个虚拟内发送VRRP通告报文。</td>
</tr>
<tr>
<td>Backup</td>
<td>当VRRP设备处于Backup状态时，它不会承担虚拟路由设备的转发工作，并定期接受Master设备的VRRP通告报文，判断Master的工作状态是否正常。</td>
</tr>
</tbody></table>
<h3 id="VRRP选举机制"><a href="#VRRP选举机制" class="headerlink" title="VRRP选举机制"></a>VRRP选举机制</h3><p>由几台路由器组成的<a target="_blank" rel="noopener" href="https://info.support.huawei.com/info-finder/encyclopedia/zh/%E8%99%9A%E6%8B%9F%E8%B7%AF%E7%94%B1%E5%99%A8.html">虚拟路由器</a>又称为VRRP备份组。一个VRRP备份组在逻辑上为一台路由器。VRRP备份组建立后，各设备会根据所配置的优先级来选举Master设备，选举方式如下图所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://download.huawei.com/mdl/image/download?uuid=090b0e71d45942fcbf40641b87ddb6a3" alt="Master设备选举过程"><br><em>Master设备选举过程</em></p>
<h3 id="VRRP工作原理"><a href="#VRRP工作原理" class="headerlink" title="VRRP工作原理"></a>VRRP工作原理</h3><p>如下图所示，路由器A、B、C通过配置VRRP组成一个虚拟路由器。虚拟路由器的IP地址可以与设备上某台设备的实际IP地址一致（实际上直接指定此设备为Master），也可以与它们的地址在同一个网段但不一致。在本例中，我们以前一种方式来举例说明，虚拟路由器的IP地址为路由器A的IP地址（注意：虚拟路由器的IP地址可以与设备上某台设备的实际IP地址一致，也可以与它们呢的地址在同一个网段但不一致。在本例中，我们以前一种方式来举例说明）。由于虚拟路由器的IP地址与路由器A的IP地址相同，因此路由器A为Master设备，路由器B、C为Backup设备。Client1-3的默认网关为10.10.0.1。作为Master设备，路由器A处理着Client1-3发往默认网关10.10.0.1的报文。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://download.huawei.com/mdl/image/download?uuid=06d8a432d7554473a4652172363441f9" alt="VRRP工作原理"><br><em>VRRP工作原理</em></p>
<p>当Master设备出现故障时，路由器B和路由器C会选举出新的Master设备。新的Master设备开始响应对虚拟IP地址的<a target="_blank" rel="noopener" href="https://info.support.huawei.com/info-finder/encyclopedia/zh/ARP.html">ARP</a>响应，并定期发送VRRP通告报文。</p>
<p><strong><code>VRRP的详细工作过程如下：</code></strong></p>
<ol>
<li>VRRP备份组中的设备根据优先级选举出Master。Master设备通过发送<a target="_blank" rel="noopener" href="https://info.support.huawei.com/info-finder/encyclopedia/zh/ARP.html">免费ARP</a>报文，将虚拟MAC地址通知给与它连接的设备或者主机，从而承担报文转发任务。</li>
<li>Master设备周期性向备份组内所有Backup设备**<code>发送VRRP通告报文，通告其配置信息（优先级等）和工作状况。</code>**</li>
<li><strong>如果Master设备出现故障，VRRP备份组中的Backup设备将根据优先级重新选举新的Master。</strong></li>
<li>VRRP备份组状态切换时，Master设备由一台设备切换为另外一台设备，新的Master设备会立即发送携带虚拟路由器的虚拟MAC地址和虚拟IP地址信息的免费ARP报文，刷新与它连接的设备或者主机的MAC表项，从而把用户流量引到新的Master设备上来，整个过程对用户完全透明。</li>
<li>原Master设备故障恢复时，若该设备为IP地址拥有者（优先级为255），将直接切换至Master状态。若该设备优先级小于255，将首先切换至Backup状态，且其优先级恢复为故障前配置的优先级。</li>
<li>Backup设备的优先级高于Master设备时，由Backup设备的工作方式（抢占方式和非抢占方式）决定是否重新选举Master。</li>
</ol>
<h3 id="VRRP应用场景"><a href="#VRRP应用场景" class="headerlink" title="VRRP应用场景"></a>VRRP应用场景</h3><p>在网络中，VRRP不仅仅在设备故障时触发Master设备的切换，它也能感知某个接口、某条路由的状态。</p>
<h2 id="20、LACP"><a href="#20、LACP" class="headerlink" title="20、LACP"></a>20、LACP</h2><h3 id="什么是LACP？"><a href="#什么是LACP？" class="headerlink" title="什么是LACP？"></a>什么是LACP？</h3><p>**<code>LACP（Link Aggregation Control Protocol，链路聚合控制协议）是一种基于IEEE802.3ad标准的实现链路动态聚合与解聚合的协议，它是链路聚合中常用的一种协议。</code>**链路聚合组中启用了LACP协议的成员端口通过发送LACPDU报文进行交互，双方对哪些端口能够发送和接收报文达成一致，确定承担业务流量的链路。此外，当聚合条件发生变化时，如某个链路发生故障，LACP模式会自动调整聚合组中的链路，组内其他可用成员链路接替故障链路维持负载平衡。这样在不进行硬件升级的情况下，可以增加设备之间的逻辑带宽，提高网络的可靠性。</p>
<p><strong>目录</strong></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://info.support.huawei.com/info-finder/encyclopedia/zh/LACP.html#content1">LACP与LAG是什么关系？</a></li>
<li><a target="_blank" rel="noopener" href="https://info.support.huawei.com/info-finder/encyclopedia/zh/LACP.html#content2">为什么要用LACP？</a></li>
<li><a target="_blank" rel="noopener" href="https://info.support.huawei.com/info-finder/encyclopedia/zh/LACP.html#content3">LACP是如何工作的？</a></li>
<li><a target="_blank" rel="noopener" href="https://info.support.huawei.com/info-finder/encyclopedia/zh/LACP.html#content4">LACP和PAgP有什么区别？</a></li>
</ul>
<h3 id="LACP与LAG是什么关系？"><a href="#LACP与LAG是什么关系？" class="headerlink" title="LACP与LAG是什么关系？"></a>LACP与LAG是什么关系？</h3><p>**<code>链路聚合组LAG（Link Aggregation Group）是指将若干条以太链路捆绑在一起形成一条逻辑链路，也称Eth-Trunk链路。</code>**每个聚合组对应一个链路聚合接口或Eth-Trunk接口，组成Eth-Trunk接口的各个物理接口称为成员接口，成员接口对应的链路称为成员链路。链路聚合接口可以作为普通的以太网接口来使用，与普通以太网接口的差别在于：转发的时候链路聚合组需要从成员接口中选择一个或多个接口来进行数据转发。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://download.huawei.com/mdl/image/download?uuid=356cb3d68c6d4316a87c61ef94f88006" alt="链路聚合组与链路聚合接口、成员接口和成员链路关系示意图"><br><em>链路聚合组与链路聚合接口、成员接口和成员链路关系示意图</em></p>
<p>LAG是一种链路聚合技术，当在两台交换机之间并行连接多个端口并将它们配置为LAG时，链路聚合组就会形成，而LACP是一种自动建立LAG的控制协议，用于启用LAG自动配置网络交换机端口、分离链路故障和激活故障切换。</p>
<p>LAG主要有两种模式，分别是手工模式和LACP模式。</p>
<ul>
<li>手工模式：指LAG不启用任何链路聚合协议，Eth-Trunk的建立、成员接口的加入由手工配置。</li>
<li>LACP模式：指LAG启用LACP链路聚合协议，Eth-Trunk的建立、成员接口的加入基于LACP协议协商完成。</li>
</ul>
<p>部分设备支持手工模式，但不支持LACP模式，**<code>LACP模式需要本端和对端设备同时启用LACP协议，所选择的活动接口必须保持一致，才能建立LAG</code>**，如果对端设备未启用LACP协议，本端LAG会尝试将数据包传输到远程单个接口，可能导致通信失败。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://download.huawei.com/mdl/image/download?uuid=a85152c1547a44fa90418c995c402fb1" alt="手工模式与LACP模式的对比"><br><em>手工模式与LACP模式的对比</em></p>
<h3 id="为什么要用LACP？"><a href="#为什么要用LACP？" class="headerlink" title="为什么要用LACP？"></a>为什么要用LACP？</h3><h3 id="LACP模式对数据传输更加稳定和可靠"><a href="#LACP模式对数据传输更加稳定和可靠" class="headerlink" title="LACP模式对数据传输更加稳定和可靠"></a>LACP模式对数据传输更加稳定和可靠</h3><p>手工模式下，所有链路都是活动链路，所有活动链路均参与数据转发，平均分担流量。如果某条活动链路故障，链路聚合组自动在剩余的活动链路中平均分担流量。</p>
<p><strong>LACP模式下，由LACP确定聚合组中的活动和非活动链路，又称为M:N模式，即M条活动链路与N条备份链路的模式。这种模式提供了更高的链路可靠性，并且可以在M条链路中实现不同方式的负载均衡。</strong></p>
<p>如下图所示，**<code>两台设备间有M+N条链路，在聚合链路上转发流量时在M条链路上分担负载，即活动链路，不在另外的N条链路转发流量，这N条链路提供备份功能，即备份链路。此时链路的实际带宽为M条链路的总和，但是能提供的最大带宽为M+N条链路的总和。当M条链路中有一条链路故障时，LACP会从N条备份链路中找出一条优先级高的可用链路替换故障链路。此时链路的实际带宽还是M条链路的总和，但是能提供的最大带宽就变为M+N-1条链路的总和。</code>**</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://download.huawei.com/mdl/image/download?uuid=88517d209a2a49b0b4d7c4544577eb9d" alt="M:N备份示意图"><br><em>M:N备份示意图</em></p>
<h3 id="LACP模式对聚合链路组的故障检测更加准确和有效"><a href="#LACP模式对聚合链路组的故障检测更加准确和有效" class="headerlink" title="LACP模式对聚合链路组的故障检测更加准确和有效"></a>LACP模式对聚合链路组的故障检测更加准确和有效</h3><p>手工模式只能检测到同一聚合组内的成员链路有断路等有限故障，LACP模式不仅能够检测到同一聚合组内的成员链路有断路等有限故障，还可以检测到链路故障、链路错连等故障。</p>
<p>如下图所示，DeviceA与DeviceB之间创建<a target="_blank" rel="noopener" href="https://info.support.huawei.com/info-finder/encyclopedia/zh/Eth-trunk.html">Eth-Trunk</a>，需要将DeviceA上的四个接口与DeviceB捆绑成一个Eth-Trunk。由于错将DeviceA上的一个接口与DeviceC相连，这将会导致DeviceA向DeviceB传输数据时可能会将本应该发到DeviceB的数据发送到DeviceC上。</p>
<p>手工模式的Eth-trunk不能及时检测到该故障，如果在DeviceA和DeviceB上都启用LACP协议，经过协商后，Eth-Trunk就会选择正确连接的链路作为活动链路来转发数据，从而DeviceA发送的数据能够正确到达DeviceB。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://download.huawei.com/mdl/image/download?uuid=fcae819d7990497ca195aaa36c4b86c9" alt="Eth-Trunk错连示意图"><br><em>Eth-Trunk错连示意图</em></p>
<h3 id="LACP是如何工作的？"><a href="#LACP是如何工作的？" class="headerlink" title="LACP是如何工作的？"></a>LACP是如何工作的？</h3><p>LACP为数据交换设备提供一种标准的协商方式，系统根据自身配置自动形成聚合链路，并启动聚合链路收发数据。**<code>LACP通过链路聚合控制协议数据单元LACPDU（Link Aggregation Control Protocol Data Unit）与对端交互信息，LACPDU报文中包含设备的系统优先级、MAC地址、接口优先级、接口号和操作Key等信息，对端接收到这些信息后，将这些信息与其它端口所保存的信息比较以选择能够汇聚的端口，双方对端口加入或退出某个动态聚合组达成一致，确定承担业务流量的链路。</code>**</p>
<p>LACP主要工作主要包含互发LACPDU报文、确定主动端、确定活动链路、链路切换，具体实现如下。</p>
<h4 id="互发LACPDU报文"><a href="#互发LACPDU报文" class="headerlink" title="互发LACPDU报文"></a>互发LACPDU报文</h4><p>在对接的两台设备上创建<a target="_blank" rel="noopener" href="https://info.support.huawei.com/info-finder/encyclopedia/zh/Eth-trunk.html">Eth-Trunk</a>并配置为LACP模式，然后向Eth-Trunk中手工加入成员接口。此时成员接口上便启用了LACP协议，两端互发LACPDU报文，LACPDU报文中包含设备的系统优先级、MAC地址、接口优先级、接口号和操作Key等信息。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://download.huawei.com/mdl/image/download?uuid=2566e3fe1b20415cbee32cfdfd2b0359" alt="互发LACPDU报文"><br><em>互发LACPDU报文</em></p>
<h4 id="确定主动端"><a href="#确定主动端" class="headerlink" title="确定主动端"></a>确定主动端</h4><p>两端设备均会收到对端发来的LACPDU报文。**<code>以DeviceB为例，当DeviceB收到DeviceA发送的报文时，DeviceB会查看并记录对端信息，然后比较系统优先级字段，如果DeviceA的系统优先级高于本端的系统优先级，则确定DeviceA为LACP主动端。如果DeviceA和DeviceB的系统优先级相同，比较两端设备的MAC地址，MAC地址小的一端为LACP主动端。</code>**</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://download.huawei.com/mdl/image/download?uuid=4ca74ab8354849fcb68579ba0fd60b9f" alt="确定主动端"><br><em>确定主动端</em></p>
<h4 id="确定活动链路"><a href="#确定活动链路" class="headerlink" title="确定活动链路"></a>确定活动链路</h4><p>**<code>选出主动端后，设备两端会以主动端的接口优先级来选择活动接口，如果主动端的接口优先级都相同则选择接口编号比较小的为活动接口。</code>**LACP模式支持设置活动接口数上限阈值以在保证带宽的情况下提高网络可靠性，当前活动接口数目达到上限阈值时，再向Eth-Trunk中添加成员接口，不会增加Eth-Trunk活动接口的数目，超过上限阈值的链路状态将被置为Down，作为备份链路。两端设备选择了一致的活动接口，活动链路组便可以建立起来，这些活动链路以负载分担的方式转发数据。</p>
<p>如下图所示，LACP模式下，如果活动链路数上限阈值为2，通过LACP协商后，链路1和链路2因为优先级较高被选作活动链路，链路3则为备份链路。聚合链路中的活动链路参与数据转发，总带宽等于被选中的活动链路带宽之和。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://download.huawei.com/mdl/image/download?uuid=cd29748b846d45a7866a52ee6b4ec1d6" alt="确定活动链路"><br><em>确定活动链路</em></p>
<h4 id="链路切换"><a href="#链路切换" class="headerlink" title="链路切换"></a>链路切换</h4><p>**<code>LACP模式链路聚合组中如果某条活动链路故障，链路聚合组自动在备份链路中选择一条优先级最高的链路作为活动链路接替故障链路，参与数据转发的链路数目不变，保证数据传输的可靠性。</code>**LACP模式链路聚合组两端设备中任何一端检测到以下事件，都会触发聚合组的链路切换：</p>
<ul>
<li>链路Down事件。</li>
<li>以太网OAM检测到链路失效。</li>
<li>LACP协议发现链路故障。</li>
<li>接口不可用。</li>
<li>在使能了LACP抢占功能的前提下，更改备份接口的优先级高于当前活动接口的优先级。</li>
</ul>
<p>当满足上述切换条件其中之一时，按照如下步骤进行切换：</p>
<ol>
<li>关闭故障链路。</li>
<li>从N条备份链路中选择优先级最高的链路接替活动链路中的故障链路。</li>
<li>优先级最高的备份链路转为活动状态并转发数据，完成切换。</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://download.huawei.com/mdl/image/download?uuid=c55716f6701146048c74a3b0458246e4" alt="链路切换"><br><em>链路切换</em></p>
<h3 id="LACP和PAgP有什么区别？"><a href="#LACP和PAgP有什么区别？" class="headerlink" title="LACP和PAgP有什么区别？"></a>LACP和PAgP有什么区别？</h3><p>LACP和PAgP（Port Aggregation Protocol，端口汇聚协议）是链路聚合中使用最广泛的两种协商协议。**<code>LACP和PAgP的功能类似，都是通过捆绑链路并协商成员链路之间的流量提高网络的可用性和稳定性。</code>**LACP和PAgP数据包在交换机之间通过支持以太网通道的端口交换。</p>
<p>**<code>它们之间最大的区别是支持的供应商不同，</code>**LACP是开放标准，可以在大多数交换机上运行，如华为S5700系列交换机，而PAgP是Cisco专有协议，只能在Cisco或支持PAgP的第三方交换机上运行。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://download.huawei.com/mdl/image/download?uuid=5a1e8589a75d4cb381935b808b0bcf08" alt="LACP vs PAgP"><br><em>LACP vs PAgP</em></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230811165312433.png" alt="image-20230811165312433"></p>
<h2 id="21、ICMP"><a href="#21、ICMP" class="headerlink" title="21、ICMP"></a>21、ICMP</h2><h3 id="什么是ICMP？"><a href="#什么是ICMP？" class="headerlink" title="什么是ICMP？"></a>什么是ICMP？</h3><p>因特网控制报文协议ICMP（Internet Control Message Protocol）是一个差错报告机制，是TCP&#x2F;IP协议簇中的一个重要子协议，通常被IP层或更高层协议（TCP或UDP）使用，**<code>属于网络层协议，主要用于在IP主机和路由器之间传递控制消息，用于报告主机是否可达、路由是否可用等。</code>**这些控制消息虽然并不传输用户数据，但是对于收集各种网络信息、诊断和排除各种网络故障以及用户数据的传递具有至关重要的作用。</p>
<p><strong>目录</strong></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://info.support.huawei.com/info-finder/encyclopedia/zh/ICMP.html#content1">为什么需要ICMP？</a></li>
<li><a target="_blank" rel="noopener" href="https://info.support.huawei.com/info-finder/encyclopedia/zh/ICMP.html#content2">ICMP如何工作？</a></li>
<li><a target="_blank" rel="noopener" href="https://info.support.huawei.com/info-finder/encyclopedia/zh/ICMP.html#content3">ICMP的典型应用</a></li>
<li><a target="_blank" rel="noopener" href="https://info.support.huawei.com/info-finder/encyclopedia/zh/ICMP.html#content4">ICMP安全</a></li>
</ul>
<h3 id="为什么需要ICMP？"><a href="#为什么需要ICMP？" class="headerlink" title="为什么需要ICMP？"></a>为什么需要ICMP？</h3><p>在数据传输的过程中，IP提供尽力而为的服务，指为了把数据包发送到目的地址尽最大努力。它并不对目的主机是否收到数据包进行验证，无法进行流量控制和差错控制。因此在数据包传输过程中，产生各种错误在所难免。**<code>为了更有效地转发IP数据包和提高数据包交付成功的机会，ICMP应运而生。使用ICMP，当网络中数据包传输出现问题时，主机或设备就会向上层协议报告差错情况和提供有关异常情况的报告，使得上层协议能够通过自己的差错控制程序来判断通信是否正确，以进行流量控制和差错控制，从而保证服务质量。</code>**</p>
<h3 id="ICMP如何工作？"><a href="#ICMP如何工作？" class="headerlink" title="ICMP如何工作？"></a>ICMP如何工作？</h3><p>从技术角度来说，ICMP就是一个差错报告机制，其工作机理也比较简单，**<code>即当数据包处理过程出现差错时，ICMP向数据包的源端设备报告这个差错，它既不会纠正这个差错，也不会通知中间的网络设备。</code><strong>因为ICMP报文被封装在IP数据包内部，作为IP数据包的数据部分通过互联网传递。</strong><code>IP数据包中的字段包含源端和最终的目的端，并没有记录报文在网络传递中的全部路径（除非IP数据包中设置了路由记录选项）。因此当设备检测到差错时，它无法通知中间的网络设备，只能向源端发送差错报告。</code>**</p>
<p>源端在收到差错报告后，它虽然不能判断差错是由中间哪个网络设备所引起的，但是却可以根据ICMP报文确定发生错误的类型，并确定如何才能更好地重发传递失败的数据包。</p>
<p>ICMP报文格式如图所示，每一个ICMP消息都将包含引发这条ICMP消息的数据包的完全IP包头，ICMP报文则作为IP数据包的数据部分封装在IP数据包内部。ICMP包头中包含的三个固定字段就是源端设备确定发生错误的类型的主要依据。</p>
<ul>
<li>Type字段表示ICMP消息的类型；</li>
<li>Code字段表示ICMP消息类型细分的子类型；</li>
<li>Checksum字段表示ICMP报文的校验和。</li>
</ul>
<p>不同的Type和Code值表示不同的ICMP报文类型，对应了数据包处理过程中可能出现的不同错误情况，不同类型的ICMP报文又分为差错报文和查询报文两种，如ICMP报文分类表所示。</p>
<p>此外，我们还要认识到，ICMP协议在以下情况下不会产生ICMP差错报文：</p>
<ul>
<li>ICMP差错报文不会产生ICMP差错报文（但ICMP查询报文可能会产生ICMP差错报文），此条规定主要为了防止ICMP消息的无限产生和传递；</li>
<li>目的地址是广播地址或<a target="_blank" rel="noopener" href="https://info.support.huawei.com/info-finder/encyclopedia/zh/%E7%BB%84%E6%92%AD.html">多播</a>地址的IP数据报文；</li>
<li>作为链路层广播的数据包；</li>
<li>不是IP分片的第一片；</li>
<li>源地址不是单个主机的数据包，也就是说，源地址不能为零地址、环回地址、广播地址或多播地址。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://download.huawei.com/mdl/image/download?uuid=8da28399608f49f18e854def7e7f2505" alt="ICMP报文格式"><br><em>ICMP报文格式</em></p>
<p><strong>表1-1</strong> ICMP报文分类</p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Code</th>
<th>描述</th>
<th>查询&#x2F;差错</th>
</tr>
</thead>
<tbody><tr>
<td>0-Echo响应</td>
<td>0</td>
<td>Echo响应报文</td>
<td>查询</td>
</tr>
<tr>
<td>3-目的不可达</td>
<td>0</td>
<td>目标网络不可达报文</td>
<td>差错</td>
</tr>
<tr>
<td>1</td>
<td>目标主机不可达报文</td>
<td>差错</td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>目标协议不可达报文</td>
<td>差错</td>
<td></td>
</tr>
<tr>
<td>3</td>
<td>目标端口不可达报文</td>
<td>差错</td>
<td></td>
</tr>
<tr>
<td>4</td>
<td>要求分段并设置DF flag标志报文</td>
<td>差错</td>
<td></td>
</tr>
<tr>
<td>5</td>
<td>源路由失败报文</td>
<td>差错</td>
<td></td>
</tr>
<tr>
<td>6</td>
<td>未知的目标网络报文</td>
<td>差错</td>
<td></td>
</tr>
<tr>
<td>7</td>
<td>未知的目标主机报文</td>
<td>差错</td>
<td></td>
</tr>
<tr>
<td>8</td>
<td>源主机隔离报文</td>
<td>差错</td>
<td></td>
</tr>
<tr>
<td>9</td>
<td>禁止访问的网络报文</td>
<td>差错</td>
<td></td>
</tr>
<tr>
<td>10</td>
<td>禁止访问的主机报文</td>
<td>差错</td>
<td></td>
</tr>
<tr>
<td>11</td>
<td>对特定的TOS网络不可达报文</td>
<td>差错</td>
<td></td>
</tr>
<tr>
<td>12</td>
<td>对特定的TOS主机不可达报文</td>
<td>差错</td>
<td></td>
</tr>
<tr>
<td>13</td>
<td>由于过滤 网络流量被禁止报文</td>
<td>差错</td>
<td></td>
</tr>
<tr>
<td>14</td>
<td>主机越权报文</td>
<td>差错</td>
<td></td>
</tr>
<tr>
<td>15</td>
<td>优先权终止生效报文</td>
<td>差错</td>
<td></td>
</tr>
<tr>
<td>5-重定向</td>
<td>0</td>
<td>重定向网络报文</td>
<td>差错</td>
</tr>
<tr>
<td>1</td>
<td>重定向主机报文</td>
<td>差错</td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>基于TOS的网络重定向报文</td>
<td>差错</td>
<td></td>
</tr>
<tr>
<td>3</td>
<td>基于TOS的主机重定向报文</td>
<td>差错</td>
<td></td>
</tr>
<tr>
<td>8-Echo请求</td>
<td>0</td>
<td>Echo请求报文</td>
<td>查询</td>
</tr>
<tr>
<td>9-路由器通告</td>
<td>0</td>
<td>路由通告报文</td>
<td>查询</td>
</tr>
<tr>
<td>10-路由器请求</td>
<td>0</td>
<td>路由器的发现&#x2F;选择&#x2F;请求报文</td>
<td>查询</td>
</tr>
<tr>
<td>11-ICMP超时</td>
<td>0</td>
<td>TTL超时报文</td>
<td>差错</td>
</tr>
<tr>
<td>1</td>
<td>分片重组超时报文</td>
<td>差错</td>
<td></td>
</tr>
<tr>
<td>12-参数问题</td>
<td>0</td>
<td>IP报首部参数错误报文</td>
<td>差错</td>
</tr>
<tr>
<td>1</td>
<td>丢失必要选项报文</td>
<td>差错</td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>不支持的长度报文</td>
<td>差错</td>
<td></td>
</tr>
<tr>
<td>13-时间戳请求</td>
<td>0</td>
<td>时间戳请求报文</td>
<td>查询</td>
</tr>
<tr>
<td>14-时间戳应答</td>
<td>0</td>
<td>时间戳应答报文</td>
<td>查询</td>
</tr>
<tr>
<td>15-信息请求</td>
<td>0</td>
<td>信息请求报文</td>
<td>查询</td>
</tr>
<tr>
<td>16-信息应答</td>
<td>0</td>
<td>信息应答报文</td>
<td>查询</td>
</tr>
</tbody></table>
<h3 id="ICMP的典型应用"><a href="#ICMP的典型应用" class="headerlink" title="ICMP的典型应用"></a>ICMP的典型应用</h3><p>IP数据报及其他应用程序通过ICMP报文可以实现多种应用，其中Ping程序和Tracert（Traceroute）程序最为常见。此外，在网络管理和监测中，网络质量分析<a target="_blank" rel="noopener" href="https://info.support.huawei.com/info-finder/encyclopedia/zh/NQA.html">NQA</a>（Network Quality Analysis）技术更加充分应用了ICMP。</p>
<h3 id="Ping"><a href="#Ping" class="headerlink" title="Ping"></a>Ping</h3><p>Ping程序是最常见的用于检测IPv4和<a target="_blank" rel="noopener" href="https://info.support.huawei.com/info-finder/encyclopedia/zh/IPv6%2B.html">IPv6</a>网络设备是否可达的调试手段，它使用ICMP的echo信息来确定：</p>
<ul>
<li>远程设备是否可达；</li>
<li>与远程主机通信的来回旅程（round-trip）的延迟；</li>
<li>报文包的丢失情况。</li>
</ul>
<h3 id="Tracert"><a href="#Tracert" class="headerlink" title="Tracert"></a>Tracert</h3><p>Tracert程序主要用于查看数据包从源端到目的端的路径信息，从而检查网络连接是否可用。当网络出现故障时，用户可以使用该命令定位故障点。</p>
<p>Tracert利用ICMP超时信息和目的不可达信息来确定从一个主机到网络上其他主机的路由，并显示IP网络中每一跳的延迟（这里的延迟是指：分组从信息源发送到目的地所需的时间，延迟也分为许多的种类——传播延迟、传输延迟、处理延迟、排队延迟等）。</p>
<h3 id="NQA"><a href="#NQA" class="headerlink" title="NQA"></a>NQA</h3><p>网络质量分析NQA（Network Quality Analysis）是一种实时的网络性能探测和统计技术，可以对响应时间、网络抖动、丢包率等网络信息进行统计。NQA能够实时监视网络服务质量，在网络发生故障时进行有效的故障诊断和定位。</p>
<p>利用不同类型的ICMP报文，NQA实现了Ping和Tracert功能的扩展和增强，可以实现对网络运行状况的准确测试，输出统计信息。比如NQA的ICMP测试、ICMP Jitter测试和Trace测试等。</p>
<ul>
<li><p>ICMP测试</p>
<p>ICMP测试是通过发送ICMP Echo请求报文和Echo响应报文来判断目的地的可达性、计算网络响应时间及丢包率，从而清晰地反映出网络性能及畅通情况。ICMP测试提供类似于命令行下的Ping命令功能，但输出信息更为丰富。</p>
</li>
<li><p>ICMP Jitter测试</p>
<p>ICMP Jitter测试是以ICMP报文为承载，通过记录在报文中的时间戳信息来统计时延、抖动、丢包的一种测试方法。Jitter（抖动时间）是指相邻两个报文的接收时间间隔减去这两个报文的发送时间间隔。</p>
</li>
<li><p>Trace测试</p>
<p>NQA的Trace测试用于检测源端到目的端的转发路径，并沿该路径记录源设备到中间各个设备的时延等信息。Trace测试类似于Tracert命令功能，但输出信息更为丰富。每一跳信息中能够显示平均时延、丢包、最后一个包接收时间等信息。</p>
</li>
</ul>
<h3 id="ICMP安全"><a href="#ICMP安全" class="headerlink" title="ICMP安全"></a>ICMP安全</h3><p>ICMP对于网络安全具有极为重要的意义。ICMP本身非常简单，它并不具有验证机制，这也导致它非常容易被用于攻击交换机、路由器等网络设备。</p>
<h3 id="ICMP攻击"><a href="#ICMP攻击" class="headerlink" title="ICMP攻击"></a>ICMP攻击</h3><p>目前ICMP攻击绝大部分都可以归类为拒绝服务攻击（Denial of Service, DOS），其中最为常见的是ICMP泛洪攻击，是指攻击者在短时间内向目标设备发送大量的ICMP虚假报文，导致目标设备忙于应付无用报文，而无法为用户提供正常服务，其过程如下图所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://download.huawei.com/mdl/image/download?uuid=9c91c00882f4468c9b9063adb57fc9db" alt="ICMP泛红攻击"><br><em>ICMP泛红攻击</em></p>
<p>ICMP泛洪攻击具体又可分为针对带宽的DOS攻击和端口扫描攻击（针对连接的DOS攻击）两类：</p>
<ul>
<li><p>针对带宽的DOS攻击</p>
<p>攻击者发送大量伪造的ICMP Echo请求报文，交换机、路由器等网络设备的CPU需要响应这种报文，会占用大量的带宽和CPU资源，这种DOS攻击和其他DOS攻击一样，消耗设备的资源而使得设备无法提供正常服务。</p>
<p>ICMP Echo响应报文具有较高的优先级，在一般情况下，网络总是允许内部主机使用Ping命令。 这种攻击仅限于攻击网络带宽，单个攻击者就能发起这种攻击。更厉害的攻击形式，如smurf，可以使整个子网内的主机对目标主机进行攻击，从而扩大ICMP流量。</p>
</li>
<li><p>端口扫描攻击（针对连接的DOS攻击）</p>
<p>端口扫描是指攻击者发送大量的端口扫描报文，交换机需要回应大量的ICMP目的不可达报文，这种攻击既消耗系统的资源，同时攻击者能够很轻易获得设备开启的端口，然后可以针对这些端口进行攻击，可以影响所有IP设备的网络连接。</p>
</li>
</ul>
<p>此外，还有<strong>针对主机的DOS攻击</strong>，又被称为<strong>Ping-of-Death</strong>，主要是攻击操作系统的漏洞。</p>
<p>由于在早期的阶段，路由器对包的最大尺寸都有限制，许多操作系统在TCP&#x2F;IP栈的实现中，对ICMP包的最大长度规定为64KB，并且在对ICMP包头进行读取之后，要根据该包头里包含的信息来为有效载荷生成缓冲区。当收到畸形的、声称自己的尺寸超过ICMP报文最大长度的包，接收方设备根据这个信息将分配超过64KB的有效载荷，就会出现内存分配错误，导致TCP&#x2F;IP堆栈崩溃，从而产生宕机。</p>
<p>根据这个原理，可以简单通过发送一个非法的ICMP Echo请求报文，就可以使目标系统崩溃或重启。许多系统包括Windows、Unix、Macintosh ，还有一些交换机、路由器和打印机，都容易遭受此类攻击。如果用户使用的操作系统的版本过于陈旧，请确保打好了补丁。</p>
<h3 id="ICMP攻击防范"><a href="#ICMP攻击防范" class="headerlink" title="ICMP攻击防范"></a>ICMP攻击防范</h3><p>ICMP协议在网络数据传输和网络管理与监测中具有极为重要的作用，同时其本身对于网络安全也具有极为重要的意义。因此，为了减轻设备处理ICMP报文的压力以及防范ICMP攻击，ICMP攻击防范技术尤为重要。目前主要采用ICMP报文限速、ICMP报文合法性检查、丢弃不需要处理的ICMP报文和不响应不可达报文来防范攻击，保护设备的CPU资源。</p>
<ul>
<li><p>报文限速</p>
<p>ICMP报文限速包括端口限速、<a target="_blank" rel="noopener" href="https://info.support.huawei.com/info-finder/encyclopedia/zh/VLAN.html">VLAN</a>限速和全局限速，同时也实现芯片的限速，通过多个维度来保证ICMP的洪泛攻击。</p>
</li>
<li><p>合法性检查&amp;丢弃不需要处理的报文</p>
<p>对于一些不合法的ICMP报文，比如TTL为0、ICMP类型为15、16、17的报文，都直接丢弃，同时可配置丢弃一些不常用或基本不使用的ICMP报文，包括TTL为1、带选项、不可达的ICMP报文。</p>
</li>
<li><p>不响应不可达报文</p>
<p>在用户通过发送大量端口不可达或网络不可达报文攻击设备时，设备收到这些报文后可以不响应，直接丢弃，以保护CPU资源。</p>
</li>
</ul>
<h2 id="22、ARP"><a href="#22、ARP" class="headerlink" title="22、ARP"></a>22、ARP</h2><h3 id="ARP地址解析过程"><a href="#ARP地址解析过程" class="headerlink" title="ARP地址解析过程"></a>ARP地址解析过程</h3><p>ARP通过以ARP请求和ARP应答这两个过程完成地址解析。</p>
<p><strong>图2-2</strong> ARP请求过程<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://download.huawei.com/mdl/image/download?uuid=c1bd1232572a4f9a9387654bbe3e9d79" alt="img"></p>
<p>如<a target="_blank" rel="noopener" href="https://support.huawei.com/enterprise/zh/doc/EDOC1100198436/6bb92fd8#fig_dc_fd_ARP_000101">图2-2</a>所示，HOSTA和HOSTB在同一网段，HOSTA要向HOSTB发送信息。</p>
<p>首先，HOSTA查看自己的ARP表，确定其中是否包含有HOSTB对应的ARP表项。如果找到了HOSTB对应的MAC地址，则HOSTA直接利用ARP表中的MAC地址，对IP数据包进行帧封装，并将数据包发送给HOSTB。</p>
<p>如果HOSTA在ARP表中找不到对应的MAC地址，则将缓存该数据报文，然后以广播方式发送一个ARP请求报文。ARP请求报文中的发送端IP地址和发送端MAC地址为HOSTA的IP地址和MAC地址，目标IP地址为HOSTB的IP地址，目标MAC地址为全0的MAC地址。由于ARP请求报文以广播方式发送，该网段上的所有主机都可以接收到该请求，但只有被请求的主机（即HOSTB）会对该请求进行处理。</p>
<p><strong>图2-3</strong> ARP响应过程<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://download.huawei.com/mdl/image/download?uuid=41f98e5bde17482cbcc5ed048f2e031d" alt="img"></p>
<p>HOSTB比较自己的IP地址和ARP请求报文中的目标IP地址，当两者相同时进行如下处理：**<code>将ARP请求报文中的发送端（即HOSTA）的IP地址和MAC地址存入自己的ARP表中。</code>**之后以单播方式发送ARP响应报文给HOSTA，其中包含了自己的MAC地址。如<a target="_blank" rel="noopener" href="https://support.huawei.com/enterprise/zh/doc/EDOC1100198436/6bb92fd8#fig_dc_fd_ARP_000102">图2-3</a>所示，HOSTB向HOSTA发出一个包含其MAC地址的ARP响应报文。</p>
<p>HOSTA收到ARP响应报文后，将HOSTB的MAC地址加入到自己的ARP表中以用于后续报文的转发，同时将IP数据包进行封装后发送出去。</p>
<h3 id="免费ARP"><a href="#免费ARP" class="headerlink" title="免费ARP"></a>免费ARP</h3><p>主机主动使用自己的IP地址作为目标地址发送ARP请求，此种方式称免费ARP。免费ARP有三方面的作用：</p>
<ul>
<li>**<code>用于检查重复的IP地址</code>**：正常情况下不会收到ARP回应，如果收到，则表明本网络中存在与自身IP地址重复的地址。</li>
<li>**<code>用于通告一个新的MAC地址</code>**：发送方更换了网卡，MAC地址变化了，为了能够在ARP表项老化前通告所有主机，发送方可以发送一个免费ARP。</li>
<li>**<code>在VRRP备份组中用来通告主备发生变换</code>**：发生主备变换后，MASTER交换机会在备份组中发送一个免费ARP报文来通告发生了主备变换。</li>
</ul>
<blockquote>
<p>ARP：地址解析协议，数据链路层之上（2.5层协议），属于2层之上又不属于3层协议，在已知IP地址的情况下，求与之对应的mac地址。</p>
</blockquote>
<blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230729180822929.png" alt="image-20230729180822929"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230729180942949.png" alt="image-20230729180942949"></p>
<blockquote>
<p>上述为ARP报文格式</p>
</blockquote>
<blockquote>
<p>在ipv4网络中，ARP必须存在，在ipv6网络中，ARP不存在（在ipv6网络中，没有广播的概念）</p>
</blockquote>
</blockquote>
<blockquote>
<p>数据封装：</p>
<ul>
<li>目的IP地址（基于上层协议（ICMP）进行封装）是通过ping地址获取的或者通过浏览器输入地址或者通过软件点击相应功能模块获取</li>
<li>目的mac地址（基于上层协议（ARP）进行封装）</li>
</ul>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230729172557379.png" alt="image-20230729172557379"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230729173741105.png" alt="image-20230729173741105"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230729174953133.png" alt="image-20230729174953133"></p>
<blockquote>
<p>当一个设备收到一个广播报文会怎么处理？</p>
<blockquote>
<p>首先看这个报文是不是给自己的，发现是一个广播报，必须强制接受和处理</p>
<blockquote>
<p>首先拆开二层，查看目的mac是全F，发现是一个广播报文，必须处理，其次进行FCS（CRC的校验），校验完之后，比对FCS字段，发现没有问题，然后拆开ARP，查看traget-ip（目的ip）是不是自己的ip地址，发现不是自己，则丢弃，发现是自己，则回复一个ARP应答（单播）</p>
</blockquote>
<blockquote>
<p>请求方发送的报文叫ARP请求；接受方发送的报文叫ARP应答</p>
</blockquote>
</blockquote>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230729182340221.png" alt="image-20230729182340221"></p>
<blockquote>
<p><strong>ip与掩码做一个与的运算</strong></p>
</blockquote>
<blockquote>
<p>查看ARP映射表（ARP缓存表）命令：arp -a</p>
</blockquote>
<blockquote>
<p>在ensp中，路由器的子接口默认不能发送ARP广播</p>
<p>路由器子接口开启ARP广播命令</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230729231618379.png" alt="image-20230729231618379"></p>
</blockquote>
<h2 id="23、TCP和UDP"><a href="#23、TCP和UDP" class="headerlink" title="23、TCP和UDP"></a>23、TCP和UDP</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230729190019354.png" alt="image-20230729190019354"></p>
<h2 id="24、OSPF"><a href="#24、OSPF" class="headerlink" title="24、OSPF"></a>24、OSPF</h2><blockquote>
<p>动态路由：通过在设备上运行某种协议，通过这个协议自动交互路由信息。+</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230731000455993.png" alt="image-20230731000455993"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230730232508715.png" alt="image-20230730232508715"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230730232537357.png" alt="image-20230730232537357"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230730235819122.png" alt="image-20230730235819122"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230731001427106.png" alt="image-20230731001427106"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230731002134802.png" alt="image-20230731002134802"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230731002843176.png" alt="image-20230731002843176"></p>
<h2 id="25、ACL"><a href="#25、ACL" class="headerlink" title="25、ACL"></a>25、ACL</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230802180415183.png" alt="image-20230802180415183"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230802183945653.png" alt="image-20230802183945653"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230802181414101.png" alt="image-20230802181414101"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230802193901218.png" alt="image-20230802193901218"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230802213705174.png" alt="image-20230802213705174"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230802214817023.png" alt="image-20230802214817023"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230802215303555.png" alt="image-20230802215303555"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230802215452214.png" alt="image-20230802215452214"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230802220032767.png" alt="image-20230802220032767"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230802220305306.png" alt="image-20230802220305306"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230802220325870.png" alt="image-20230802220325870"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230802100639244.png" alt="image-20230802100639244"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230802095048016.png" alt="image-20230802095048016"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230802095119459.png" alt="image-20230802095119459"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230802095148946.png" alt="image-20230802095148946"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230802101257382.png" alt="image-20230802101257382"></p>
<blockquote>
<p>需求：pc1不能访问pc2，pc1能访问pc3，使用标准acl将pc1的源ip地址禁止。</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230802100436023.png" alt="image-20230802100436023"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230802100452834.png" alt="image-20230802100452834"></p>
<blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230802101457079.png" alt="image-20230802101457079"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230802101534101.png" alt="image-20230802101534101"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230802101952937.png" alt="image-20230802101952937"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230802105240286.png" alt="image-20230802105240286"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230802111636484.png" alt="image-20230802111636484"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230802111647477.png" alt="image-20230802111647477"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230802111701735.png" alt="image-20230802111701735">	</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230802113009077.png" alt="image-20230802113009077"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230802113737026.png" alt="image-20230802113737026"></p>
<p><strong>使用高级acl：</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230802114537410.png" alt="image-20230802114537410"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230802114551573.png" alt="image-20230802114551573"></p>
</blockquote>
<blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230802150517860.png" alt="image-20230802150517860"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230802150530944.png" alt="image-20230802150530944"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230802150558056.png" alt="image-20230802150558056"></p>
<blockquote>
<p>主要区别在于匹配单向访问</p>
</blockquote>
<p><strong>当电脑上运行某个应用后，查询应用对应的端口命令</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230802152818367.png" alt="image-20230802152818367"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230802153324857.png" alt="image-20230802153324857"></p>
</blockquote>
<h2 id="26、PPP"><a href="#26、PPP" class="headerlink" title="26、PPP"></a>26、PPP</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230802231501855.png" alt="image-20230802231501855"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230802232626709.png" alt="image-20230802232626709"></p>
<h2 id="27、PPPoE"><a href="#27、PPPoE" class="headerlink" title="27、PPPoE"></a>27、PPPoE</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230806014133881.png" alt="image-20230806014133881"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230806020936310.png" alt="image-20230806020936310"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230806021004905.png" alt="image-20230806021004905"></p>
<h2 id="28、RIP"><a href="#28、RIP" class="headerlink" title="28、RIP"></a>28、RIP</h2><h3 id="RIP简介"><a href="#RIP简介" class="headerlink" title="RIP简介"></a>RIP简介</h3><p>介绍RIP的定义及目的。</p>
<h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>RIP是Routing Information Protocol（路由信息协议）的简称，它是一种较为简单的**<code>内部网关协议（Interior Gateway Protocol）</code><strong>。RIP是一种基于</strong><code>距离矢量（Distance-Vector）算法的协议</code><strong>，它使用</strong><code>跳数（Hop Count）作为度量</code><strong>来衡量到达目的网络的距离。</strong><code>RIP通过UDP报文进行路由信息的交换</code><strong>，使用的</strong><code>端口号为520</code>**。</p>
<p>RIP包括RIP-1和RIP-2两个版本，RIP-2对RIP-1进行了扩充，使其更具有优势。</p>
<h4 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h4><p>由于RIP的实现较为简单，在配置和维护管理方面也远比OSPF和IS-IS容易，因此**<code>RIP主要应用于规模较小的网络中</code>**，例如校园网以及结构较简单的地区性网络。对于更为复杂的环境和大型网络，一般不使用RIP协议。</p>
<h3 id="RIP基本原理"><a href="#RIP基本原理" class="headerlink" title="RIP基本原理"></a>RIP基本原理</h3><p>RIP是一种基于距离矢量（Distance-Vector）算法的协议，它使用跳数（Hop Count）作为度量值来衡量到达目的地址的距离。在RIP网络中，**<code>缺省情况下，设备到与它直接相连网络的跳数为0</code><strong>，通过一个设备可达的网络的跳数为1，其余依此类推。也就是说，</strong><code>度量值等于从本网络到达目的网络间的设备数量。</code><strong>为限制收敛时间，</strong><code>RIP规定度量值取0～15之间的整数，大于或等于16的跳数被定义为无穷大，即目的网络或主机不可达。由于这个限制，使得RIP不可能在大型网络中得到应用。</code>**</p>
<p>1、RIP动态路由协议的基本配置</p>
<blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230807185159477.png" alt="image-20230807185159477"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230807185131406.png" alt="image-20230807185131406"></p>
</blockquote>
<p><strong>2、RIP动态路由协议的工作过程</strong></p>
<blockquote>
<blockquote>
<p><strong><code>1、运行RIP路由器，每过30秒，会把自己完整路由表发送给直接相连的邻居，并且发送出去的时候以跳数加1发出去。</code></strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230807185809389.png" alt="image-20230807185809389"></p>
</blockquote>
<blockquote>
<p><strong><code>2、当R2收到R1的路由表以后，先检查自己路由表，如果自己的路由表中没有就学习，如有，则比较度量值，R2会把度量值小的路由放到路由表中。</code></strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230807191027137.png" alt="image-20230807191027137"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230807191223150.png" alt="image-20230807191223150"></p>
</blockquote>
<blockquote>
<p><strong><code>3、3台路由器（都启用了rip协议）相互学习完的最终路由表</code></strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230807192500277.png" alt="image-20230807192500277"></p>
</blockquote>
<blockquote>
<p>在RIP中是以跳数作为度量值。</p>
</blockquote>
</blockquote>
<p>3、解决距离矢量型路由协议环路的办法</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230807221030201.png" alt="image-20230807221030201"></p>
<blockquote>
<p><strong>&#96;&#96;第一种方法（触发更新）：一旦链路出现了故障以后，马上通知给邻居，触发更新不是用来解决环路的，而是用来避免环路的发生，RIP默认就启用的一个功能。</strong></p>
<p><strong>第二种方法（度量值）：RIP是以跳数作为度量值，它的有效跳数只有15跳，当到达一个目的需要16跳的时候，RIP会认为该目的是不可达的，那么RIP会丢弃这个数据包，因此RIP有这样的特性，所以它不能应用在大型的网络中。</strong></p>
<blockquote>
<p><strong>注：但是这样的方式导致最终的结果是数据包被丢弃</strong></p>
</blockquote>
<p><strong>第三种方法（水平分割）：路由器不会把从一个接口学习到的路由，再从该接口发送出去，默认也是启用。</strong></p>
<p><strong>第四种方法（路由中毒&#x2F;毒性反转&#x2F;路由毒化）：路由器中的某一条路由出现了故障，路由器会马上向外发送一条该路由跳数为16跳的路由，默认启用的。</strong></p>
<p><strong>第五种方法（RIP计时器）：</strong></p>
<p>查看命令：display rip</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230807225322177.png" alt="image-20230807225322177"></p>
<blockquote>
<p><strong>RIP每过30秒会发送自己完整的路由表给它的邻居，如果在180秒内，没有收到邻居的路由表，那么该路由就会认为邻居出现了故障。但这个时候，该路由器还认为即使邻居出现了故障，但是它相信邻居会重新和我连接，所以180秒后，邻居的路由还在我的路由表中，然后在开始倒计时120秒，如果120秒内，邻居还没有和我建立连接，那么该路由器就会认为邻居出现了故障，从而在自己的路由表中删除该邻居的路由信息。</strong></p>
</blockquote>
</blockquote>
<p>4、RIPv1和RIPv2的区别以及报头格式</p>
<blockquote>
<p>（1）允许RIP的路由器会发送request和response两种类型的数据包和对方建立邻居关系（request是请求，response是给request的应答）</p>
<p>（2）RIPv1使用的是广播和单播来建立邻居关系，并且使用广播的方式来更新路由（默认RIP运行的都是v1）</p>
<p>（3）RIP的封装结构示意图：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230807233117763.png" alt="image-20230807233117763"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230807233253939.png" alt="image-20230807233253939"></p>
<blockquote>
<p><strong><code>通过抓包分析报头格式</code></strong></p>
<p>ip报头中，如果协议号是1，代表的是ICMP，17代表的是UDP，6代表的是TCP</p>
<p>RIP使用的是UDP的源和目的的520端口</p>
<p>在RIP报头中：request的协议号是1，response的协议号是2</p>
</blockquote>
<p>（4）RIPv1不连续子网的问题，<strong>因为RIPv1会对路由进行自动汇总，所以就产生了不连续子网的问题。要解决这个问题，需要使用RIPv2</strong>，RIPv2不会对路由进行自动汇总</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230808002337098.png" alt="image-20230808002337098"></p>
<blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230808001733491.png" alt="image-20230808001733491"></p>
</blockquote>
<p>RIPv2手动汇总：</p>
<p>配置命令：<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230808004703908.png" alt="image-20230808004703908"></p>
<blockquote>
<p>作用：减小路由表的大小，从而提高路由器的性能</p>
<p>注意：如果删除了所有的明细路由，那么手动汇总路由也会消失</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230808004536914.png" alt="image-20230808004536914"></p>
</blockquote>
<p>5、RIP的验证</p>
<blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230808005418817.png" alt="image-20230808005418817"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230808005441911.png" alt="image-20230808005441911"></p>
</blockquote>
<p>6、引入外部路由</p>
<blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230808005817081.png" alt="image-20230808005817081"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230808010131168.png" alt="image-20230808010131168"></p>
</blockquote>
<p>7、附加度量值</p>
<blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230808010643913.png" alt="image-20230808010643913"></p>
</blockquote>
<h2 id="29-OSPF"><a href="#29-OSPF" class="headerlink" title="29 OSPF"></a>29 OSPF</h2><p>1、OSPF的基本配置</p>
<blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230808014310520.png" alt="image-20230808014310520"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230808014428248.png" alt="image-20230808014428248"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230808014459567.png" alt="image-20230808014459567"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230808015356837.png" alt="image-20230808015356837"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230808015652952.png" alt="image-20230808015652952"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230808015941643.png" alt="image-20230808015941643"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230808020159831.png" alt="image-20230808020159831"></p>
</blockquote>
<p>2、OSPF数据结构封装示意图</p>
<blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230808020434503.png" alt="image-20230808020434503"></p>
</blockquote>
<p>3、OSPF协议的特点</p>
<blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230808020620577.png" alt="image-20230808020620577"></p>
</blockquote>
<blockquote>
<p>查看邻居命令：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230808162817616.png" alt="image-20230808162817616"></p>
</blockquote>
<p><strong>在广播网络中建立OSPF邻接关系的过程如下</strong></p>
<p><strong><code>1、建立邻居关系</code></strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230809100225385.png" alt="image-20230809100225385"></p>
<p><strong><code>2、主/从关系协商、DD报文交换</code></strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230809095644098.png" alt="image-20230809095644098"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230809095850147.png" alt="image-20230809095850147"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230809095915108.png" alt="image-20230809095915108"></p>
<p><strong><code>3、LSDB同步（LSA请求、LSA传输、LSA应答）</code></strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230809100325866.png" alt="image-20230809100325866"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230809100350228.png" alt="image-20230809100350228"></p>
<table>
<thead>
<tr>
<th>LSA类型</th>
<th>LSA作用</th>
</tr>
</thead>
<tbody><tr>
<td>Router-LSA（Type1）</td>
<td>每个设备都会产生，描述了设备的链路状态和开销，在所属的区域内传播。</td>
</tr>
<tr>
<td>Network-LSA（Type2）</td>
<td>由DR（Designated Router）产生，描述本网段的链路状态，在所属的区域内传播。</td>
</tr>
<tr>
<td>Network-summary-LSA（Type3）</td>
<td>由ABR产生，描述区域内某个网段的路由，并通告给发布或接收此LSA的非Totally STUB或NSSA区域。例如：ABR同时属于Area0和Area1，Area0内存在网段10.1.1.0，Area1内存在网段11.1.1.0，ABR为Area0生成到网段11.1.1.0的Type3 LSA；ABR为Area1生成到网段10.1.1.0的Type3 LSA，并通告给发布或接收此LSA的非Totally Stub或NSSA区域。</td>
</tr>
<tr>
<td>ASBR-summary-LSA（Type4）</td>
<td>由ABR产生，描述到ASBR的路由，通告给除ASBR所在区域的其他相关区域。</td>
</tr>
<tr>
<td>AS-external-LSA（Type5）</td>
<td>由ASBR产生，描述到AS外部的路由，通告到所有的区域（除了STUB区域和NSSA区域）。</td>
</tr>
<tr>
<td>NSSA LSA（Type7）</td>
<td>由ASBR产生，描述到AS外部的路由，仅在NSSA区域内传播。</td>
</tr>
<tr>
<td>Opaque LSA（Type9&#x2F;Type10&#x2F;Type11）</td>
<td>Opaque LSA提供用于OSPF的扩展的通用机制。其中：Type9 LSA仅在接口所在网段范围内传播。用于支持GR的Grace LSA就是Type9 LSA的一种。Type10 LSA在区域内传播。用于支持TE的LSA就是Type10 LSA的一种。Type11 LSA在自治域内传播，目前还没有实际应用的例子。</td>
</tr>
</tbody></table>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230810112219557.png" alt="image-20230810112219557"></p>
<blockquote>
<p>LSA承载了进行路由计算的一些信息，换言之理解就是相对于每个区域都由设备分开了，那LSA就相对于通行证，不同区域使用不同的通行证</p>
<p>LSA-1：在相同区域内进行泛红式传输，用于告诉对方自己相关的路由信息，只要运行OSPF的，一定会发送LSA-1，LSA-1只会在自己的区域内进行传递，其他区域内部也会互相发送LSA-1（基本的路由信息），上面视图其他区域的LSA-1只是没有标注出来</p>
<p>LSA-2：只用于DR和BDR和成员之间互相去记录相关信息的，在点到点网路中没有LSA-2</p>
<p>LSA-3：两台设备之间的信息可以通过LSA-3发送到另外一个区域，产生LSA-3的设备一定是ABR设备</p>
<p>LSA-5：在ASBR设备上引入外部的路由，在ASBR设备上会产生LSA-5，LSA-5不受区域的限制，在普通区域中都可以传输，在stub区域不能传输</p>
<p>LSA-4：作为LSA-5的辅助，LSA-4不必去深究</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/image-20230810112317566.png" alt="image-20230810112317566"></p>
<blockquote>
<p><strong><code>stub（末节区域）和NSSA（非纯末节区域）这两种特殊区域类型</code></strong></p>
<p>在stub区域内，LSA-5无法传输，那么设备将无法上网（不能连外网），信息无法进入stub区域，没有办法计算路由，就不能上网，这个时候，内部的stub区域的ABR设备会下发一条默认路由，默认路由可以节省我们的路由表，它可以和外界通信，stub区域只需要一条默认路由就可以上网了，即解决了上网的问题，还可以减少LSA-5进入stub区域，减少路由器计算的工作量</p>
<p>stub区域不能自己连接外网</p>
<p>NSSA区域解决了stub区域不能连接外网的问题，还可以防止外部的LSA-5进入stub区域</p>
<p><strong>注意：特殊区域只能配置在非骨干区域中</strong></p>
</blockquote>
</div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/654b452cc458853aef60e7d7.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">燃烧的炸弹猫</div><div class="author-info__description">来自一个爱记录学习和生活的小赵同学</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">4</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">11</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/ZHDBurning"><i class="fab fa-github"></i><span>前往小家..</span></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/ZHDBurning" target="_blank" title="Github"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-github"></use></svg></a><a class="social-icon faa-parent animated-hover" href="/assets/weixin.png" target="_blank" title="微信"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-weixin"></use></svg></a><a class="social-icon faa-parent animated-hover" href="/assets/qq.png" target="_blank" title="qq"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-qq"></use></svg></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><a class="faa-parent animated-hover"><svg class="faa-tada icon" style="height:25px;width:25px;fill:currentColor;position:relative;top:5px" aria-hidden="true"><use xlink:href="#icon-xinwengonggao"></use></svg></a><span>公告栏</span></div><div class="announcement_content">欢迎来到我的博客, 博客还在建设中，希望你能从中有所收获, 这将是我的荣幸</div></div><div class="sticky_layout"><div class="card-widget card-webinfo"><div class="item-headline"><a class="faa-parent animated-hover"><svg class="faa-tada icon" style="height:25px;width:25px;fill:currentColor;position:relative;top:5px" aria-hidden="true"><use xlink:href="#icon-tongjitu"></use></svg></a><span>小站资讯</span></div><div class="webinfo"><div class="webinfo-item"><div class="item-name">文章数目 :</div><div class="item-count">4</div></div><div class="webinfo-item"><div class="item-name">本站总字数 :</div><div class="item-count">19.9k</div></div><div class="webinfo-item"><div class="item-name">本站访客数 :</div><div class="item-count" id="busuanzi_value_site_uv"><i class="fa-solid fa-spinner fa-spin"></i></div></div><div class="webinfo-item"><div class="item-name">本站总访问量 :</div><div class="item-count" id="busuanzi_value_site_pv"><i class="fa-solid fa-spinner fa-spin"></i></div></div><div class="webinfo-item"><div class="item-name">最后更新时间 :</div><div class="item-count" id="last-push-date" data-lastPushDate="2023-11-08T10:21:27.772Z"><i class="fa-solid fa-spinner fa-spin"></i></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 By 燃烧的炸弹猫</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="translateLink" type="button" title="简繁转换">繁</button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"></div><script src="//at.alicdn.com/t/c/font_4135809_sbdtxij50w.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="30" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><!-- hexo injector body_end start --><div class="js-pjax"><script async="async">var arr = document.getElementsByClassName('recent-post-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '2s');
    arr[i].setAttribute('data-wow-delay', '1s');
    arr[i].setAttribute('data-wow-offset', '100');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script><script async="async">var arr = document.getElementsByClassName('card-widget');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script></div><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow_init.js"></script><script data-pjax>
  function butterfly_footer_beautify_injector_config(){
    var parent_div_git = document.getElementById('footer-wrap');
    var item_html = '<div id="workboard"></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" data-title="博客框架为Hexo_v6.2.0" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&amp;logo=hexo" alt=""/></a><a class="github-badge" target="_blank" href="https://butterfly.js.org/" style="margin-inline:5px" data-title="主题版本Butterfly_v4.3.1" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&amp;logo=bitdefender" alt=""/></a><a class="github-badge" target="_blank" href="https://vercel.com/" style="margin-inline:5px" data-title="本站采用多线部署，主线路托管于Vercel" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Hosted-Vercel-brightgreen?style=flat&amp;logo=Vercel" alt=""/></a><a class="github-badge" target="_blank" href="https://dashboard.4everland.org/" style="margin-inline:5px" data-title="本站采用多线部署，备用线路托管于4EVERLAND" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Hosted-4EVERLAND-22DDDD?style=flat&amp;logo=IPFS" alt=""/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" data-title="本站项目由Github托管" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&amp;logo=GitHub" alt=""/></a><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px" data-title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&amp;logo=Claris" alt=""/></a></p>';
    console.log('已挂载butterfly_footer_beautify')
    parent_div_git.insertAdjacentHTML("beforeend",item_html)
    }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_footer_beautify_injector_config();
  }
  else if (epage === cpage){
    butterfly_footer_beautify_injector_config();
  }
  </script><script async src="/js/runtime.js"></script><!-- hexo injector body_end end --><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":false},"log":false});</script></body></html>